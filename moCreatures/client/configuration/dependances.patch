diff -r -U 3 minecraft\net\minecraft\src\Setting.java minecraft_patched\net\minecraft\src\Setting.java
--- minecraft\net\minecraft\src\Setting.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\Setting.java	Fri Apr 01 00:00:00 2011
@@ -7,4 +7,4 @@
 import java.util.HashMap;
 
-public abstract class Setting extends Widget
+public abstract class Setting<T> extends Widget
 {
@@ -36,19 +36,19 @@
     }
 
-    public abstract void set(Object obj, String s);
+    public abstract void set(T obj, String s);
 
-    public void set(Object obj)
+    public void set(T obj)
     {
         set(obj, ModSettings.currentContext);
     }
 
-    public abstract Object get(String s);
+    public abstract T get(String s);
 
-    public Object get()
+    public T get()
     {
         return get(ModSettings.currentContext);
     }
 
-    public HashMap values;
+    public HashMap<String, T> values;
-    public Object defvalue;
+    public T defvalue;
     public String backendname;
diff -r -U 3 minecraft\net\minecraft\src\SettingBoolean.java minecraft_patched\net\minecraft\src\SettingBoolean.java
--- minecraft\net\minecraft\src\SettingBoolean.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\SettingBoolean.java	Fri Apr 01 00:00:00 2011
@@ -6,4 +6,4 @@
 import java.util.HashMap;
 
-public class SettingBoolean extends Setting
+public class SettingBoolean extends Setting<Boolean>
 {
@@ -63,6 +63,1 @@
     }
-
-    public void set(Object obj, String s)
-    {
-        set((Boolean)obj, s);
-    }
diff -r -U 3 minecraft\net\minecraft\src\SettingFloat.java minecraft_patched\net\minecraft\src\SettingFloat.java
--- minecraft\net\minecraft\src\SettingFloat.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\SettingFloat.java	Fri Apr 01 00:00:00 2011
@@ -6,4 +6,4 @@
 import java.util.HashMap;
 
-public class SettingFloat extends Setting
+public class SettingFloat extends Setting<Float>
 {
@@ -88,6 +88,1 @@
     }
-
-    public void set(Object obj, String s)
-    {
-        set((Float)obj, s);
-    }
diff -r -U 3 minecraft\net\minecraft\src\SettingInt.java minecraft_patched\net\minecraft\src\SettingInt.java
--- minecraft\net\minecraft\src\SettingInt.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\SettingInt.java	Fri Apr 01 00:00:00 2011
@@ -6,4 +6,4 @@
 import java.util.HashMap;
 
-public class SettingInt extends Setting
+public class SettingInt extends Setting<Integer>
 {
@@ -90,6 +90,1 @@
     }
-
-    public void set(Object obj, String s)
-    {
-        set((Integer)obj, s);
-    }
diff -r -U 3 minecraft\net\minecraft\src\SettingKey.java minecraft_patched\net\minecraft\src\SettingKey.java
--- minecraft\net\minecraft\src\SettingKey.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\SettingKey.java	Fri Apr 01 00:00:00 2011
@@ -6,4 +6,4 @@
 import java.util.HashMap;
 
-public class SettingKey extends Setting
+public class SettingKey extends Setting<Integer>
 {
@@ -96,6 +96,1 @@
     }
-
-    public void set(Object obj, String s)
-    {
-        set((Integer)obj, s);
-    }
diff -r -U 3 minecraft\net\minecraft\src\SettingMulti.java minecraft_patched\net\minecraft\src\SettingMulti.java
--- minecraft\net\minecraft\src\SettingMulti.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\SettingMulti.java	Fri Apr 01 00:00:00 2011
@@ -6,4 +6,4 @@
 import java.util.HashMap;
 
-public class SettingMulti extends Setting
+public class SettingMulti extends Setting<Integer>
 {
@@ -131,6 +131,1 @@
     }
-
-    public void set(Object obj, String s)
-    {
-        set((Integer)obj, s);
-    }
diff -r -U 3 minecraft\net\minecraft\src\SettingText.java minecraft_patched\net\minecraft\src\SettingText.java
--- minecraft\net\minecraft\src\SettingText.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\SettingText.java	Fri Apr 01 00:00:00 2011
@@ -6,4 +6,4 @@
 import java.util.HashMap;
 
-public class SettingText extends Setting
+public class SettingText extends Setting<String>
 {
@@ -58,6 +58,1 @@
     }
-
-    public void set(Object obj, String s)
-    {
-        set((String)obj, s);
-    }
diff -r -U 3 minecraft\net\minecraft\src\BaseMod.java minecraft_patched\net\minecraft\src\BaseMod.java
--- minecraft\net\minecraft\src\BaseMod.java	Fri Apr 01 00:00:00 2011
+++ minecraft_patched\net\minecraft\src\BaseMod.java	Fri Apr 01 00:00:00 2011
@@ -25,4 +25,4 @@
     }
 
-    public void AddRenderer(Map map)
+    public void AddRenderer(Map<Class<? extends Entity>, Render> map)
     {
diff -r -U 3 minecraft\net\minecraft\src\ModLoader.java minecraft_patched\net\minecraft\src\ModLoader.java
--- minecraft\net\minecraft\src\ModLoader.java	Sat Jun 11 16:12:09 2011
+++ minecraft_patched\net\minecraft\src\ModLoader.java	Sat Jun 11 16:12:59 2011
@@ -1,9 +1,7 @@
-// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
-// Jad home page: http://www.kpdus.com/jad.html
-// Decompiler options: packimports(3) braces deadcode 
-
 package net.minecraft.src;
 
+import net.minecraft.src.BaseMod;
+import java.awt.image.BufferedImage;
 import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
@@ -44,1578 +42,1259 @@
 import net.minecraft.client.Minecraft;
 import org.lwjgl.input.Keyboard;
 
-// Referenced classes of package net.minecraft.src:
-//            Achievement, StatBase, StatCollector, BaseMod, 
-//            TextureFX, StringTranslate, MLProp, Item, 
-//            Block, ItemStack, CraftingManager, FurnaceRecipes, 
-//            BiomeGenBase, EnumCreatureType, SpawnListEntry, EntityLiving, 
-//            World, EntityRendererProxy, EntityList, Session, 
-//            TileEntityRenderer, RenderPlayer, RenderEngine, BiomeGenHell, 
-//            TileEntity, RenderBlocks, StatList, StatCrafting, 
-//            IRecipe, TexturePackList, TexturePackBase, GameSettings, 
-//            KeyBinding, IChunkProvider, ModTextureStatic, ItemBlock, 
-//            TileEntitySpecialRenderer, EntityPlayer, UnexpectedThrowable, GuiScreen, 
-//            IBlockAccess
-
 public final class ModLoader
 {
-
-    public ModLoader()
-    {
-    }
-
-    public static void AddAchievementDesc(Achievement achievement, String s, String s1)
-    {
-        try
-        {
-            if(achievement.field_25070_e.contains("."))
-            {
-                String s2 = achievement.field_25070_e.split("\\.")[1];
-                AddLocalization((new StringBuilder("achievement.")).append(s2).toString(), s);
-                AddLocalization((new StringBuilder("achievement.")).append(s2).append(".desc").toString(), s1);
-                setPrivateValue(net.minecraft.src.StatBase.class, achievement, 1, StatCollector.func_25200_a((new StringBuilder("achievement.")).append(s2).toString()));
-                setPrivateValue(net.minecraft.src.Achievement.class, achievement, 3, StatCollector.func_25200_a((new StringBuilder("achievement.")).append(s2).append(".desc").toString()));
-            } else
-            {
-                setPrivateValue(net.minecraft.src.StatBase.class, achievement, 1, s);
-                setPrivateValue(net.minecraft.src.Achievement.class, achievement, 3, s1);
-            }
-        }
-        catch(IllegalArgumentException illegalargumentexception)
-        {
-            logger.throwing("ModLoader", "AddAchievementDesc", illegalargumentexception);
-            ThrowException(illegalargumentexception);
-        }
-        catch(SecurityException securityexception)
-        {
-            logger.throwing("ModLoader", "AddAchievementDesc", securityexception);
-            ThrowException(securityexception);
-        }
-        catch(NoSuchFieldException nosuchfieldexception)
-        {
-            logger.throwing("ModLoader", "AddAchievementDesc", nosuchfieldexception);
-            ThrowException(nosuchfieldexception);
-        }
-    }
-
-    public static int AddAllFuel(int i)
-    {
-        logger.finest((new StringBuilder("Finding fuel for ")).append(i).toString());
-        int j = 0;
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext();)
-        {
-            BaseMod basemod = (BaseMod)iterator.next();
-            if((j = basemod.AddFuel(i)) == 0)
-            {
-                logger.finest((new StringBuilder("Returned ")).append(j).toString());
-                break;
-            }
-        }
-
-        return j;
-    }
-
-    public static void AddAllRenderers(Map map)
-    {
-        if(!hasInit)
-        {
-            init();
-            logger.fine("Initialized");
-        }
-        BaseMod basemod;
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext(); basemod.AddRenderer(map))
-        {
-            basemod = (BaseMod)iterator.next();
-        }
-
-    }
-
-    public static void addAnimation(TextureFX texturefx)
-    {
-        logger.finest((new StringBuilder("Adding animation ")).append(texturefx.toString()).toString());
-        for(Iterator iterator = animList.iterator(); iterator.hasNext();)
-        {
-            TextureFX texturefx1 = (TextureFX)iterator.next();
-            if(texturefx1.field_1126_b == texturefx.field_1126_b)
-            {
-                animList.remove(texturefx);
-                break;
-            }
-        }
-
-        animList.add(texturefx);
-    }
-
-    public static int AddArmor(String s)
-    {
-        try
-        {
-            String as[] = (String[])field_armorList.get(null);
-            List list = Arrays.asList(as);
-            ArrayList arraylist = new ArrayList();
-            arraylist.addAll(list);
-            if(!arraylist.contains(s))
-            {
-                arraylist.add(s);
-            }
-            int i = arraylist.indexOf(s);
-            field_armorList.set(null, ((Object) (arraylist.toArray(new String[0]))));
-            return i;
-        }
-        catch(IllegalArgumentException illegalargumentexception)
-        {
-            logger.throwing("ModLoader", "AddArmor", illegalargumentexception);
-            ThrowException("An impossible error has occured!", illegalargumentexception);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "AddArmor", illegalaccessexception);
-            ThrowException("An impossible error has occured!", illegalaccessexception);
-        }
-        return -1;
-    }
-
-    public static void AddLocalization(String s, String s1)
-    {
-        Properties properties = null;
-        try
-        {
-            properties = (Properties)getPrivateValue(net.minecraft.src.StringTranslate.class, StringTranslate.func_20162_a(), 1);
-        }
-        catch(SecurityException securityexception)
-        {
-            logger.throwing("ModLoader", "AddLocalization", securityexception);
-            ThrowException(securityexception);
-        }
-        catch(NoSuchFieldException nosuchfieldexception)
-        {
-            logger.throwing("ModLoader", "AddLocalization", nosuchfieldexception);
-            ThrowException(nosuchfieldexception);
-        }
-        if(properties != null)
-        {
-            properties.put(s, s1);
-        }
-    }
-
-    private static void addMod(ClassLoader classloader, String s, String s1)
-    {
-        try
-        {
-            s1 = s1.substring(0, s1.lastIndexOf('.'));
-            if(!s1.contains("$") && (!props.containsKey(s) || !props.getProperty(s).equalsIgnoreCase("no") && !props.getProperty(s).equalsIgnoreCase("off")))
-            {
-                Class class1 = classloader.loadClass(s1);
-                if((net.minecraft.src.BaseMod.class).isAssignableFrom(class1))
-                {
-                    setupProperties(class1);
-                    BaseMod basemod = (BaseMod)class1.newInstance();
-                    String s2 = basemod.toString();
-                    if(basemod != null && !modList.containsKey(s2))
-                    {
-                        modList.put(s2, basemod);
-                        logger.fine((new StringBuilder("Mod Loaded: \"")).append(s2).append("\" from ").append(s).toString());
-                        System.out.println((new StringBuilder("Mod Loaded: ")).append(s2).toString());
-                    }
-                }
-            }
-        }
-        catch(Throwable throwable)
-        {
-            logger.fine((new StringBuilder("Failed to load mod from \"")).append(s).append("\"").toString());
-            System.out.println((new StringBuilder("Failed to load mod from \"")).append(s).append("\"").toString());
-            logger.throwing("ModLoader", "addMod", throwable);
-            ThrowException(throwable);
-        }
-    }
-
-    private static void setupProperties(Class class1)
-        throws IllegalArgumentException, IllegalAccessException, IOException, SecurityException, NoSuchFieldException
-    {
-        Properties properties = new Properties();
-        File file = new File(cfgdir, (new StringBuilder(String.valueOf(class1.getName()))).append(".cfg").toString());
-        if(file.exists() && file.canRead())
-        {
-            properties.load(new FileInputStream(file));
-        }
-        StringBuilder stringbuilder = new StringBuilder();
-        Field afield[];
-        int j = (afield = class1.getFields()).length;
-        for(int i = 0; i < j; i++)
-        {
-            Field field = afield[i];
-            if((field.getModifiers() & 8) == 0 || !field.isAnnotationPresent(net.minecraft.src.MLProp.class))
-            {
-                continue;
-            }
-            Class class2 = field.getType();
-            MLProp mlprop = (MLProp)field.getAnnotation(net.minecraft.src.MLProp.class);
-            String s = mlprop.name().length() != 0 ? mlprop.name() : field.getName();
-            Object obj = field.get(null);
-            StringBuilder stringbuilder1 = new StringBuilder();
-            if(mlprop.min() != (-1.0D / 0.0D))
-            {
-                stringbuilder1.append(String.format(",>=%.1f", new Object[] {
-                    Double.valueOf(mlprop.min())
-                }));
-            }
-            if(mlprop.max() != (1.0D / 0.0D))
-            {
-                stringbuilder1.append(String.format(",<=%.1f", new Object[] {
-                    Double.valueOf(mlprop.max())
-                }));
-            }
-            StringBuilder stringbuilder2 = new StringBuilder();
-            if(mlprop.info().length() > 0)
-            {
-                stringbuilder2.append(" -- ");
-                stringbuilder2.append(mlprop.info());
-            }
-            stringbuilder.append(String.format("%s (%s:%s%s)%s\n", new Object[] {
-                s, class2.getName(), obj, stringbuilder1, stringbuilder2
-            }));
-            if(properties.containsKey(s))
-            {
-                String s1 = properties.getProperty(s);
-                Object obj1 = null;
-                if(class2.isAssignableFrom(java.lang.String.class))
-                {
-                    obj1 = s1;
-                } else
-                if(class2.isAssignableFrom(Integer.TYPE))
-                {
-                    obj1 = Integer.valueOf(Integer.parseInt(s1));
-                } else
-                if(class2.isAssignableFrom(Short.TYPE))
-                {
-                    obj1 = Short.valueOf(Short.parseShort(s1));
-                } else
-                if(class2.isAssignableFrom(Byte.TYPE))
-                {
-                    obj1 = Byte.valueOf(Byte.parseByte(s1));
-                } else
-                if(class2.isAssignableFrom(Boolean.TYPE))
-                {
-                    obj1 = Boolean.valueOf(Boolean.parseBoolean(s1));
-                } else
-                if(class2.isAssignableFrom(Float.TYPE))
-                {
-                    obj1 = Float.valueOf(Float.parseFloat(s1));
-                } else
-                if(class2.isAssignableFrom(Double.TYPE))
-                {
-                    obj1 = Double.valueOf(Double.parseDouble(s1));
-                }
-                if(obj1 == null)
-                {
-                    continue;
-                }
-                if(obj1 instanceof Number)
-                {
-                    double d = ((Number)obj1).doubleValue();
-                    if(mlprop.min() != (-1.0D / 0.0D) && d < mlprop.min() || mlprop.max() != (1.0D / 0.0D) && d > mlprop.max())
-                    {
-                        continue;
-                    }
-                }
-                logger.finer((new StringBuilder(String.valueOf(s))).append(" set to ").append(obj1).toString());
-                if(!obj1.equals(obj))
-                {
-                    field.set(null, obj1);
-                }
-            } else
-            {
-                logger.finer((new StringBuilder(String.valueOf(s))).append(" not in config, using default: ").append(obj).toString());
-                properties.setProperty(s, obj.toString());
-            }
-        }
-
-        if(!properties.isEmpty() && (file.exists() || file.createNewFile()) && file.canWrite())
-        {
-            properties.store(new FileOutputStream(file), stringbuilder.toString());
-        }
-    }
-
-    public static void AddName(Object obj, String s)
-    {
-        String s1 = null;
-        if(obj instanceof Item)
-        {
-            Item item = (Item)obj;
-            if(item.func_20009_a() != null)
-            {
-                s1 = (new StringBuilder(String.valueOf(item.func_20009_a()))).append(".name").toString();
-            }
-        } else
-        if(obj instanceof Block)
-        {
-            Block block = (Block)obj;
-            if(block.func_20013_i() != null)
-            {
-                s1 = (new StringBuilder(String.valueOf(block.func_20013_i()))).append(".name").toString();
-            }
-        } else
-        if(obj instanceof ItemStack)
-        {
-            ItemStack itemstack = (ItemStack)obj;
-            if(itemstack.func_20109_f() != null)
-            {
-                s1 = (new StringBuilder(String.valueOf(itemstack.func_20109_f()))).append(".name").toString();
-            }
-        } else
-        {
-            Exception exception = new Exception((new StringBuilder(String.valueOf(obj.getClass().getName()))).append(" cannot have name attached to it!").toString());
-            logger.throwing("ModLoader", "AddName", exception);
-            ThrowException(exception);
-        }
-        if(s1 != null)
-        {
-            AddLocalization(s1, s);
-        } else
-        {
-            Exception exception1 = new Exception((new StringBuilder()).append(obj).append(" is missing name tag!").toString());
-            logger.throwing("ModLoader", "AddName", exception1);
-            ThrowException(exception1);
-        }
-    }
-
-    public static int addOverride(String s, String s1)
-    {
-        try
-        {
-            int i = getUniqueSpriteIndex(s);
-            addOverride(s, s1, i);
-            return i;
-        }
-        catch(Throwable throwable)
-        {
-            logger.throwing("ModLoader", "addOverride", throwable);
-            ThrowException(throwable);
-            throw new RuntimeException(throwable);
-        }
-    }
-
-    public static void addOverride(String s, String s1, int i)
-    {
-        int j = -1;
-        int k = 0;
-        if(s.equals("/terrain.png"))
-        {
-            j = 0;
-            k = terrainSpritesLeft;
-        } else
-        if(s.equals("/gui/items.png"))
-        {
-            j = 1;
-            k = itemSpritesLeft;
-        } else
-        {
-            return;
-        }
-        System.out.println((new StringBuilder("Overriding ")).append(s).append(" with ").append(s1).append(" @ ").append(i).append(". ").append(k).append(" left.").toString());
-        logger.finer((new StringBuilder("addOverride(")).append(s).append(",").append(s1).append(",").append(i).append("). ").append(k).append(" left.").toString());
-        Object obj = (Map)overrides.get(Integer.valueOf(j));
-        if(obj == null)
-        {
-            obj = new HashMap();
-            overrides.put(Integer.valueOf(j), obj);
-        }
-        ((Map) (obj)).put(s1, Integer.valueOf(i));
-    }
-
-    public static void AddRecipe(ItemStack itemstack, Object aobj[])
-    {
-        CraftingManager.func_1120_a().func_1121_a(itemstack, aobj);
-    }
-
-    public static void AddShapelessRecipe(ItemStack itemstack, Object aobj[])
-    {
-        CraftingManager.func_1120_a().func_21187_b(itemstack, aobj);
-    }
-
-    public static void AddSmelting(int i, ItemStack itemstack)
-    {
-        FurnaceRecipes.func_21200_a().func_21199_a(i, itemstack);
-    }
-
-    public static void AddSpawn(Class class1, int i, EnumCreatureType enumcreaturetype)
-    {
-        AddSpawn(class1, i, enumcreaturetype, null);
-    }
-
-    public static void AddSpawn(Class class1, int i, EnumCreatureType enumcreaturetype, BiomeGenBase abiomegenbase[])
-    {
-        if(class1 == null)
-        {
-            throw new IllegalArgumentException("entityClass cannot be null");
-        }
-        if(enumcreaturetype == null)
-        {
-            throw new IllegalArgumentException("spawnList cannot be null");
-        }
-        if(abiomegenbase == null)
-        {
-            abiomegenbase = standardBiomes;
-        }
-        for(int j = 0; j < abiomegenbase.length; j++)
-        {
-            List list = abiomegenbase[j].func_25063_a(enumcreaturetype);
-            if(list != null)
-            {
-                boolean flag = false;
-                for(Iterator iterator = list.iterator(); iterator.hasNext();)
-                {
-                    SpawnListEntry spawnlistentry = (SpawnListEntry)iterator.next();
-                    if(spawnlistentry.field_25212_a == class1)
-                    {
-                        spawnlistentry.field_25211_b = i;
-                        flag = true;
-                        break;
-                    }
-                }
-
-                if(!flag)
-                {
-                    list.add(new SpawnListEntry(class1, i));
-                }
-            }
-        }
-
-    }
-
-    public static void AddSpawn(String s, int i, EnumCreatureType enumcreaturetype)
-    {
-        AddSpawn(s, i, enumcreaturetype, null);
-    }
-
-    public static void AddSpawn(String s, int i, EnumCreatureType enumcreaturetype, BiomeGenBase abiomegenbase[])
-    {
-        Class class1 = (Class)classMap.get(s);
-        if(class1 != null && (net.minecraft.src.EntityLiving.class).isAssignableFrom(class1))
-        {
-            AddSpawn(class1, i, enumcreaturetype, abiomegenbase);
-        }
-    }
-
-    public static boolean DispenseEntity(World world, double d, double d1, double d2, int i, 
-            int j, ItemStack itemstack)
-    {
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext();)
-        {
-            BaseMod basemod = (BaseMod)iterator.next();
-            if(basemod.DispenseEntity(world, d, d1, d2, i, j, itemstack))
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    public static List getLoadedMods()
-    {
-        return Collections.unmodifiableList(new LinkedList(modList.values()));
-    }
-
-    public static Logger getLogger()
-    {
-        return logger;
-    }
-
-    public static Minecraft getMinecraftInstance()
-    {
-        if(instance == null)
-        {
-            try
-            {
-                ThreadGroup threadgroup = Thread.currentThread().getThreadGroup();
-                int i = threadgroup.activeCount();
-                Thread athread[] = new Thread[i];
-                threadgroup.enumerate(athread);
-                Thread athread1[];
-                int k = (athread1 = athread).length;
-                for(int j = 0; j < k; j++)
-                {
-                    Thread thread = athread1[j];
-                    if(!thread.getName().equals("Minecraft main thread"))
-                    {
-                        continue;
-                    }
-                    instance = (Minecraft)getPrivateValue(java.lang.Thread.class, thread, "target");
-                    break;
-                }
-
-            }
-            catch(SecurityException securityexception)
-            {
-                logger.throwing("ModLoader", "getMinecraftInstance", securityexception);
-                throw new RuntimeException(securityexception);
-            }
-            catch(NoSuchFieldException nosuchfieldexception)
-            {
-                logger.throwing("ModLoader", "getMinecraftInstance", nosuchfieldexception);
-                throw new RuntimeException(nosuchfieldexception);
-            }
-        }
-        return instance;
-    }
-
-    public static Object getPrivateValue(Class class1, Object obj, int i)
-        throws IllegalArgumentException, SecurityException, NoSuchFieldException
-    {
-        try
-        {
-            Field field = class1.getDeclaredFields()[i];
-            field.setAccessible(true);
-            return field.get(obj);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "getPrivateValue", illegalaccessexception);
-            ThrowException("An impossible error has occured!", illegalaccessexception);
-            return null;
-        }
-    }
-
-    public static Object getPrivateValue(Class class1, Object obj, String s)
-        throws IllegalArgumentException, SecurityException, NoSuchFieldException
-    {
-        try
-        {
-            Field field = class1.getDeclaredField(s);
-            field.setAccessible(true);
-            return field.get(obj);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "getPrivateValue", illegalaccessexception);
-            ThrowException("An impossible error has occured!", illegalaccessexception);
-            return null;
-        }
-    }
-
-    public static int getUniqueBlockModelID(BaseMod basemod, boolean flag)
-    {
-        int i = nextBlockModelID++;
-        blockModels.put(Integer.valueOf(i), basemod);
-        blockSpecialInv.put(Integer.valueOf(i), Boolean.valueOf(flag));
-        return i;
-    }
-
-    public static int getUniqueEntityId()
-    {
-        return highestEntityId++;
-    }
-
-    private static int getUniqueItemSpriteIndex()
-    {
-        for(; itemSpriteIndex < usedItemSprites.length; itemSpriteIndex++)
-        {
-            if(!usedItemSprites[itemSpriteIndex])
-            {
-                usedItemSprites[itemSpriteIndex] = true;
-                itemSpritesLeft--;
-                return itemSpriteIndex++;
-            }
-        }
-
-        Exception exception = new Exception("No more empty item sprite indices left!");
-        logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
-        ThrowException(exception);
-        return 0;
-    }
-
-    public static int getUniqueSpriteIndex(String s)
-    {
-        if(s.equals("/gui/items.png"))
-        {
-            return getUniqueItemSpriteIndex();
-        }
-        if(s.equals("/terrain.png"))
-        {
-            return getUniqueTerrainSpriteIndex();
-        } else
-        {
-            Exception exception = new Exception((new StringBuilder("No registry for this texture: ")).append(s).toString());
-            logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
-            ThrowException(exception);
-            return 0;
-        }
-    }
-
-    private static int getUniqueTerrainSpriteIndex()
-    {
-        for(; terrainSpriteIndex < usedTerrainSprites.length; terrainSpriteIndex++)
-        {
-            if(!usedTerrainSprites[terrainSpriteIndex])
-            {
-                usedTerrainSprites[terrainSpriteIndex] = true;
-                terrainSpritesLeft--;
-                return terrainSpriteIndex++;
-            }
-        }
-
-        Exception exception = new Exception("No more empty terrain sprite indices left!");
-        logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
-        ThrowException(exception);
-        return 0;
-    }
-
-    private static void init()
-    {
-        hasInit = true;
-        String s = "1111111111111111111111111111111111111101111111011111111111111001111111111111111111111111111010111111100110000011111110000000001111111001100000110000000100000011000000010000001100000000000000110000000000000000000000000000000000000000000000001100000000000000";
-        String s1 = "1111111111111111111111111111110111111111111111111111110111111111111111111111000111111011111111111111001111000000111111111111100011111111000010001111011110000000111111000000000011111100000000001111000000000111111000000000001101000000000001111111111111000011";
-        for(int i = 0; i < 256; i++)
-        {
-            usedItemSprites[i] = s.charAt(i) == '1';
-            if(!usedItemSprites[i])
-            {
-                itemSpritesLeft++;
-            }
-            usedTerrainSprites[i] = s1.charAt(i) == '1';
-            if(!usedTerrainSprites[i])
-            {
-                terrainSpritesLeft++;
-            }
-        }
-
-        try
-        {
-            instance = (Minecraft)getPrivateValue(net.minecraft.client.Minecraft.class, null, 1);
-            instance.field_9243_r = new EntityRendererProxy(instance);
-            classMap = (Map)getPrivateValue(net.minecraft.src.EntityList.class, null, 0);
-            field_modifiers = (java.lang.reflect.Field.class).getDeclaredField("modifiers");
-            field_modifiers.setAccessible(true);
-            field_blockList = (net.minecraft.src.Session.class).getDeclaredFields()[0];
-            field_blockList.setAccessible(true);
-            field_TileEntityRenderers = (net.minecraft.src.TileEntityRenderer.class).getDeclaredFields()[0];
-            field_TileEntityRenderers.setAccessible(true);
-            field_armorList = (net.minecraft.src.RenderPlayer.class).getDeclaredFields()[3];
-            field_modifiers.setInt(field_armorList, field_armorList.getModifiers() & 0xffffffef);
-            field_armorList.setAccessible(true);
-            field_animList = (net.minecraft.src.RenderEngine.class).getDeclaredFields()[5];
-            field_animList.setAccessible(true);
-            Field afield[] = (net.minecraft.src.BiomeGenBase.class).getDeclaredFields();
-            LinkedList linkedlist = new LinkedList();
-            for(int j = 0; j < afield.length; j++)
-            {
-                Class class1 = afield[j].getType();
-                if((afield[j].getModifiers() & 8) != 0 && class1.isAssignableFrom(net.minecraft.src.BiomeGenBase.class))
-                {
-                    BiomeGenBase biomegenbase = (BiomeGenBase)afield[j].get(null);
-                    if(!(biomegenbase instanceof BiomeGenHell))
-                    {
-                        linkedlist.add(biomegenbase);
-                    }
-                }
-            }
-
-            standardBiomes = (BiomeGenBase[])linkedlist.toArray(new BiomeGenBase[0]);
-            try
-            {
-                method_RegisterTileEntity = (net.minecraft.src.TileEntity.class).getDeclaredMethod("a", new Class[] {
-                    java.lang.Class.class, java.lang.String.class
-                });
-            }
-            catch(NoSuchMethodException nosuchmethodexception1)
-            {
-                method_RegisterTileEntity = (net.minecraft.src.TileEntity.class).getDeclaredMethod("addMapping", new Class[] {
-                    java.lang.Class.class, java.lang.String.class
-                });
-            }
-            method_RegisterTileEntity.setAccessible(true);
-            try
-            {
-                method_RegisterEntityID = (net.minecraft.src.EntityList.class).getDeclaredMethod("a", new Class[] {
-                    java.lang.Class.class, java.lang.String.class, Integer.TYPE
-                });
-            }
-            catch(NoSuchMethodException nosuchmethodexception2)
-            {
-                method_RegisterEntityID = (net.minecraft.src.EntityList.class).getDeclaredMethod("addMapping", new Class[] {
-                    java.lang.Class.class, java.lang.String.class, Integer.TYPE
-                });
-            }
-            method_RegisterEntityID.setAccessible(true);
-        }
-        catch(SecurityException securityexception)
-        {
-            logger.throwing("ModLoader", "init", securityexception);
-            ThrowException(securityexception);
-            throw new RuntimeException(securityexception);
-        }
-        catch(NoSuchFieldException nosuchfieldexception)
-        {
-            logger.throwing("ModLoader", "init", nosuchfieldexception);
-            ThrowException(nosuchfieldexception);
-            throw new RuntimeException(nosuchfieldexception);
-        }
-        catch(NoSuchMethodException nosuchmethodexception)
-        {
-            logger.throwing("ModLoader", "init", nosuchmethodexception);
-            ThrowException(nosuchmethodexception);
-            throw new RuntimeException(nosuchmethodexception);
-        }
-        catch(IllegalArgumentException illegalargumentexception)
-        {
-            logger.throwing("ModLoader", "init", illegalargumentexception);
-            ThrowException(illegalargumentexception);
-            throw new RuntimeException(illegalargumentexception);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "init", illegalaccessexception);
-            ThrowException(illegalaccessexception);
-            throw new RuntimeException(illegalaccessexception);
-        }
-        try
-        {
-            loadConfig();
-            if(props.containsKey("loggingLevel"))
-            {
-                cfgLoggingLevel = Level.parse(props.getProperty("loggingLevel"));
-            }
-            if(props.containsKey("grassFix"))
-            {
-                RenderBlocks.cfgGrassFix = Boolean.parseBoolean(props.getProperty("grassFix"));
-            }
-            logger.setLevel(cfgLoggingLevel);
-            if((logfile.exists() || logfile.createNewFile()) && logfile.canWrite() && logHandler == null)
-            {
-                logHandler = new FileHandler(logfile.getPath());
-                logHandler.setFormatter(new SimpleFormatter());
-                logger.addHandler(logHandler);
-            }
-            logger.fine("ModLoader Beta 1.6.6 Initializing...");
-            System.out.println("ModLoader Beta 1.6.6 Initializing...");
-            File file = new File((net.minecraft.src.ModLoader.class).getProtectionDomain().getCodeSource().getLocation().toURI());
-            modDir.mkdirs();
-            readFromModFolder(modDir);
-            readFromClassPath(file);
-            System.out.println("Done.");
-            props.setProperty("loggingLevel", cfgLoggingLevel.getName());
-            props.setProperty("grassFix", Boolean.toString(RenderBlocks.cfgGrassFix));
-            for(Iterator iterator = modList.values().iterator(); iterator.hasNext();)
-            {
-                BaseMod basemod = (BaseMod)iterator.next();
-                basemod.ModsLoaded();
-                if(!props.containsKey(basemod.getClass().getName()))
-                {
-                    props.setProperty(basemod.getClass().getName(), "on");
-                }
-            }
-
-            initStats();
-            saveConfig();
-        }
-        catch(Throwable throwable)
-        {
-            logger.throwing("ModLoader", "init", throwable);
-            ThrowException("ModLoader has failed to initialize.", throwable);
-            if(logHandler != null)
-            {
-                logHandler.close();
-            }
-            throw new RuntimeException(throwable);
-        }
-    }
-
-    private static void initStats()
-    {
-        for(int i = 0; i < Block.field_345_n.length; i++)
-        {
-            if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1000000 + i)) && Block.field_345_n[i] != null && Block.field_345_n[i].func_27033_k())
-            {
-                String s = StatCollector.func_25199_a("stat.mineBlock", new Object[] {
-                    Block.field_345_n[i].func_25016_i()
-                });
-                StatList.field_25159_y[i] = (new StatCrafting(0x1000000 + i, s, i)).func_25068_c();
-                StatList.field_25185_d.add(StatList.field_25159_y[i]);
-            }
-        }
-
-        for(int j = 0; j < Item.field_233_c.length; j++)
-        {
-            if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1020000 + j)) && Item.field_233_c[j] != null)
-            {
-                String s1 = StatCollector.func_25199_a("stat.useItem", new Object[] {
-                    Item.field_233_c[j].func_25009_k()
-                });
-                StatList.field_25172_A[j] = (new StatCrafting(0x1020000 + j, s1, j)).func_25068_c();
-                if(j >= Block.field_345_n.length)
-                {
-                    StatList.field_25186_c.add(StatList.field_25172_A[j]);
-                }
-            }
-            if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1030000 + j)) && Item.field_233_c[j] != null && Item.field_233_c[j].func_25007_g())
-            {
-                String s2 = StatCollector.func_25199_a("stat.breakItem", new Object[] {
-                    Item.field_233_c[j].func_25009_k()
-                });
-                StatList.field_25170_B[j] = (new StatCrafting(0x1030000 + j, s2, j)).func_25068_c();
-            }
-        }
-
-        HashSet hashset = new HashSet();
-        Object obj;
-        for(Iterator iterator = CraftingManager.func_1120_a().func_25193_b().iterator(); iterator.hasNext(); hashset.add(Integer.valueOf(((IRecipe)obj).func_25117_b().field_1617_c)))
-        {
-            obj = iterator.next();
-        }
-
-        Object obj1;
-        for(Iterator iterator1 = FurnaceRecipes.func_21200_a().func_25194_b().values().iterator(); iterator1.hasNext(); hashset.add(Integer.valueOf(((ItemStack)obj1).field_1617_c)))
-        {
-            obj1 = iterator1.next();
-        }
-
-        for(Iterator iterator2 = hashset.iterator(); iterator2.hasNext();)
-        {
-            int k = ((Integer)iterator2.next()).intValue();
-            if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1010000 + k)) && Item.field_233_c[k] != null)
-            {
-                String s3 = StatCollector.func_25199_a("stat.craftItem", new Object[] {
-                    Item.field_233_c[k].func_25009_k()
-                });
-                StatList.field_25158_z[k] = (new StatCrafting(0x1010000 + k, s3, k)).func_25068_c();
-            }
-        }
-
-    }
-
-    public static boolean isGUIOpen(Class class1)
-    {
-        Minecraft minecraft = getMinecraftInstance();
-        if(class1 == null)
-        {
-            return minecraft.field_6313_p == null;
-        }
-        if(minecraft.field_6313_p == null && class1 != null)
-        {
-            return false;
-        } else
-        {
-            return class1.isInstance(minecraft.field_6313_p);
-        }
-    }
-
-    public static boolean isModLoaded(String s)
-    {
-        Class class1 = null;
-        try
-        {
-            class1 = Class.forName(s);
-        }
-        catch(ClassNotFoundException classnotfoundexception)
-        {
-            return false;
-        }
-        if(class1 != null)
-        {
-            for(Iterator iterator = modList.values().iterator(); iterator.hasNext();)
-            {
-                BaseMod basemod = (BaseMod)iterator.next();
-                if(class1.isInstance(basemod))
-                {
-                    return true;
-                }
-            }
-
-        }
-        return false;
-    }
-
-    public static void loadConfig()
-        throws IOException
-    {
-        cfgdir.mkdir();
-        if(!cfgfile.exists() && !cfgfile.createNewFile())
-        {
-            return;
-        }
-        if(cfgfile.canRead())
-        {
-            FileInputStream fileinputstream = new FileInputStream(cfgfile);
-            props.load(fileinputstream);
-            fileinputstream.close();
-        }
-    }
-
-    public static java.awt.image.BufferedImage loadImage(RenderEngine renderengine, String s)
-        throws Exception
-    {
-        TexturePackList texturepacklist = (TexturePackList)getPrivateValue(net.minecraft.src.RenderEngine.class, renderengine, 11);
-        InputStream inputstream = texturepacklist.field_6534_a.func_6481_a(s);
-        if(inputstream == null)
-        {
-            throw new Exception((new StringBuilder("Image not found: ")).append(s).toString());
-        }
-        java.awt.image.BufferedImage bufferedimage = ImageIO.read(inputstream);
-        if(bufferedimage == null)
-        {
-            throw new Exception((new StringBuilder("Image not found: ")).append(s).toString());
-        } else
-        {
-            return bufferedimage;
-        }
-    }
-
-    public static void OnTick(Minecraft minecraft)
-    {
-        if(!hasInit)
-        {
-            init();
-            logger.fine("Initialized");
-        }
-        if(texPack == null || minecraft.field_6304_y.field_6524_j != texPack)
-        {
-            texturesAdded = false;
-            texPack = minecraft.field_6304_y.field_6524_j;
-        }
-        if(!texturesAdded && minecraft.field_6315_n != null)
-        {
-            RegisterAllTextureOverrides(minecraft.field_6315_n);
-            texturesAdded = true;
-        }
-        long l = 0L;
-        if(minecraft.field_6324_e != null)
-        {
-            l = minecraft.field_6324_e.func_22139_r();
-            for(Iterator iterator = inGameHooks.entrySet().iterator(); iterator.hasNext();)
-            {
-                java.util.Map.Entry entry = (java.util.Map.Entry)iterator.next();
-                if(clock != l || !((Boolean)entry.getValue()).booleanValue())
-                {
-                    ((BaseMod)entry.getKey()).OnTickInGame(minecraft);
-                }
-            }
-
-        }
-        if(minecraft.field_6313_p != null)
-        {
-            for(Iterator iterator1 = inGUIHooks.entrySet().iterator(); iterator1.hasNext();)
-            {
-                java.util.Map.Entry entry1 = (java.util.Map.Entry)iterator1.next();
-                if(clock != l || !(((Boolean)entry1.getValue()).booleanValue() & (minecraft.field_6324_e != null)))
-                {
-                    ((BaseMod)entry1.getKey()).OnTickInGUI(minecraft, minecraft.field_6313_p);
-                }
-            }
-
-        }
-        if(clock != l)
-        {
-            for(Iterator iterator2 = keyList.entrySet().iterator(); iterator2.hasNext();)
-            {
-                java.util.Map.Entry entry2 = (java.util.Map.Entry)iterator2.next();
-                for(Iterator iterator3 = ((Map)entry2.getValue()).entrySet().iterator(); iterator3.hasNext();)
-                {
-                    java.util.Map.Entry entry3 = (java.util.Map.Entry)iterator3.next();
-                    boolean flag = Keyboard.isKeyDown(((KeyBinding)entry3.getKey()).field_1370_b);
-                    boolean aflag[] = (boolean[])entry3.getValue();
-                    boolean flag1 = aflag[1];
-                    aflag[1] = flag;
-                    if(flag && (!flag1 || aflag[0]))
-                    {
-                        ((BaseMod)entry2.getKey()).KeyboardEvent((KeyBinding)entry3.getKey());
-                    }
-                }
-
-            }
-
-        }
-        clock = l;
-    }
-
-    public static void OpenGUI(EntityPlayer entityplayer, GuiScreen guiscreen)
-    {
-        if(!hasInit)
-        {
-            init();
-            logger.fine("Initialized");
-        }
-        Minecraft minecraft = getMinecraftInstance();
-        if(minecraft.field_6322_g != entityplayer)
-        {
-            return;
-        }
-        if(guiscreen != null)
-        {
-            minecraft.func_6272_a(guiscreen);
-        }
-    }
-
-    public static void PopulateChunk(IChunkProvider ichunkprovider, int i, int j, World world)
-    {
-        if(!hasInit)
-        {
-            init();
-            logger.fine("Initialized");
-        }
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext();)
-        {
-            BaseMod basemod = (BaseMod)iterator.next();
-            if(ichunkprovider.func_21109_c().equals("RandomLevelSource"))
-            {
-                basemod.GenerateSurface(world, world.field_1037_n, i, j);
-            } else
-            if(ichunkprovider.func_21109_c().equals("HellRandomLevelSource"))
-            {
-                basemod.GenerateNether(world, world.field_1037_n, i, j);
-            }
-        }
-
-    }
-
-    private static void readFromModFolder(File file)
-        throws IOException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, SecurityException, NoSuchMethodException
-    {
-        if(!file.isDirectory())
-        {
-            throw new IllegalArgumentException("folder must be a Directory.");
-        } else
-        {
-            logger.finer((new StringBuilder("Adding mods from ")).append(file.getCanonicalPath()).toString());
-            System.out.println((new StringBuilder("Adding mods from ")).append(file.getCanonicalPath()).toString());
-            readFromFileRecursive(file, file);
-            return;
-        }
-    }
-
-    private static void readFromClassPath(File file)
-        throws FileNotFoundException, IOException
-    {
-        logger.finer((new StringBuilder("Adding mods from ")).append(file.getCanonicalPath()).toString());
-        System.out.println((new StringBuilder("Adding mods from ")).append(file.getCanonicalPath()).toString());
-        readFromFileRecursive(file, file.isDirectory() ? file : file.getParentFile());
-    }
-
-    private static void readFromFileRecursive(File file, File file1)
-        throws FileNotFoundException, IOException
-    {
-        String s;
-        ZipInputStream zipinputstream;
-        if(file.isDirectory())
-        {
-            File afile[];
-            int j = (afile = file.listFiles()).length;
-            for(int i = 0; i < j; i++)
-            {
-                File file2 = afile[i];
-                readFromFileRecursive(file2, file1);
-            }
-
-            break MISSING_BLOCK_LABEL_339;
-        }
-        if(!file.isFile())
-        {
-            break MISSING_BLOCK_LABEL_339;
-        }
-        s = file.getName();
-        if(!s.endsWith(".jar") && !s.endsWith(".zip"))
-        {
-            break MISSING_BLOCK_LABEL_254;
-        }
-        logger.finer((new StringBuilder("Archive found : ")).append(s).toString());
-        zipinputstream = new ZipInputStream(new BufferedInputStream(new FileInputStream(file)));
-        for(ZipEntry zipentry = zipinputstream.getNextEntry(); zipentry != null; zipentry = zipinputstream.getNextEntry())
-        {
-            String s1 = zipentry.getName();
-            String s2 = s1.substring(s1.lastIndexOf('/') + 1, s1.length());
-            if(!zipentry.isDirectory() && s2.startsWith("mod_") && s2.endsWith(".class"))
-            {
-                addMod(new URLClassLoader(new URL[] {
-                    file1.toURI().toURL()
-                }), s2, s1.replace('/', '.'));
-            }
-        }
-
-        break MISSING_BLOCK_LABEL_247;
-        Exception exception;
-        exception;
-        zipinputstream.close();
-        throw exception;
-        zipinputstream.close();
-        break MISSING_BLOCK_LABEL_339;
-        if(s.startsWith("mod_") && s.endsWith(".class"))
-        {
-            addMod(new URLClassLoader(new URL[] {
-                file1.toURI().toURL()
-            }), s, file.getAbsolutePath().replace((new StringBuilder(String.valueOf(file1.getAbsolutePath()))).append("\\").toString(), "").replace('\\', '.'));
-        }
-    }
-
-    public static KeyBinding[] RegisterAllKeys(KeyBinding akeybinding[])
-    {
-        List list = Arrays.asList(akeybinding);
-        ArrayList arraylist = new ArrayList();
-        arraylist.addAll(list);
-        Map map;
-        for(Iterator iterator = keyList.values().iterator(); iterator.hasNext(); arraylist.addAll(map.keySet()))
-        {
-            map = (Map)iterator.next();
-        }
-
-        return (KeyBinding[])arraylist.toArray(new KeyBinding[0]);
-    }
-
-    public static void RegisterAllTextureOverrides(RenderEngine renderengine)
-    {
-        animList.clear();
-        Minecraft minecraft = getMinecraftInstance();
-        BaseMod basemod;
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext(); basemod.RegisterAnimation(minecraft))
-        {
-            basemod = (BaseMod)iterator.next();
-        }
-
-        TextureFX texturefx;
-        for(Iterator iterator1 = animList.iterator(); iterator1.hasNext(); renderengine.func_1066_a(texturefx))
-        {
-            texturefx = (TextureFX)iterator1.next();
-        }
-
-        for(Iterator iterator2 = overrides.entrySet().iterator(); iterator2.hasNext();)
-        {
-            java.util.Map.Entry entry = (java.util.Map.Entry)iterator2.next();
-            for(Iterator iterator3 = ((Map)entry.getValue()).entrySet().iterator(); iterator3.hasNext();)
-            {
-                java.util.Map.Entry entry1 = (java.util.Map.Entry)iterator3.next();
-                String s = (String)entry1.getKey();
-                int i = ((Integer)entry1.getValue()).intValue();
-                int j = ((Integer)entry.getKey()).intValue();
-                String s1 = null;
-                if(j == 0)
-                {
-                    s1 = "/terrain.png";
-                } else
-                if(j == 1)
-                {
-                    s1 = "/gui/items.png";
-                } else
-                {
-                    throw new ArrayIndexOutOfBoundsException(j);
-                }
-                try
-                {
-                    java.awt.image.BufferedImage bufferedimage = loadImage(renderengine, s);
-                    ModTextureStatic modtexturestatic = new ModTextureStatic(i, j, bufferedimage);
-                    renderengine.func_1066_a(modtexturestatic);
-                }
-                catch(Exception exception)
-                {
-                    logger.throwing("ModLoader", "RegisterAllTextureOverrides", exception);
-                    ThrowException(exception);
-                    throw new RuntimeException(exception);
-                }
-            }
-
-        }
-
-    }
-
-    public static void RegisterBlock(Block block)
-    {
-        RegisterBlock(block, null);
-    }
-
-    public static void RegisterBlock(Block block, Class class1)
-    {
-        try
-        {
-            if(block == null)
-            {
-                throw new IllegalArgumentException("block parameter cannot be null.");
-            }
-            List list = (List)field_blockList.get(null);
-            list.add(block);
-            int i = block.field_376_bc;
-            ItemBlock itemblock = null;
-            if(class1 != null)
-            {
-                itemblock = (ItemBlock)class1.getConstructor(new Class[] {
-                    Integer.TYPE
-                }).newInstance(new Object[] {
-                    Integer.valueOf(i - 256)
-                });
-            } else
-            {
-                itemblock = new ItemBlock(i - 256);
-            }
-            if(Block.field_345_n[i] != null && Item.field_233_c[i] == null)
-            {
-                Item.field_233_c[i] = itemblock;
-            }
-        }
-        catch(IllegalArgumentException illegalargumentexception)
-        {
-            logger.throwing("ModLoader", "RegisterBlock", illegalargumentexception);
-            ThrowException(illegalargumentexception);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "RegisterBlock", illegalaccessexception);
-            ThrowException(illegalaccessexception);
-        }
-        catch(SecurityException securityexception)
-        {
-            logger.throwing("ModLoader", "RegisterBlock", securityexception);
-            ThrowException(securityexception);
-        }
-        catch(InstantiationException instantiationexception)
-        {
-            logger.throwing("ModLoader", "RegisterBlock", instantiationexception);
-            ThrowException(instantiationexception);
-        }
-        catch(InvocationTargetException invocationtargetexception)
-        {
-            logger.throwing("ModLoader", "RegisterBlock", invocationtargetexception);
-            ThrowException(invocationtargetexception);
-        }
-        catch(NoSuchMethodException nosuchmethodexception)
-        {
-            logger.throwing("ModLoader", "RegisterBlock", nosuchmethodexception);
-            ThrowException(nosuchmethodexception);
-        }
-    }
-
-    public static void RegisterEntityID(Class class1, String s, int i)
-    {
-        try
-        {
-            method_RegisterEntityID.invoke(null, new Object[] {
-                class1, s, Integer.valueOf(i)
-            });
-        }
-        catch(IllegalArgumentException illegalargumentexception)
-        {
-            logger.throwing("ModLoader", "RegisterEntityID", illegalargumentexception);
-            ThrowException(illegalargumentexception);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "RegisterEntityID", illegalaccessexception);
-            ThrowException(illegalaccessexception);
-        }
-        catch(InvocationTargetException invocationtargetexception)
-        {
-            logger.throwing("ModLoader", "RegisterEntityID", invocationtargetexception);
-            ThrowException(invocationtargetexception);
-        }
-    }
-
-    public static void RegisterKey(BaseMod basemod, KeyBinding keybinding, boolean flag)
-    {
-        Object obj = (Map)keyList.get(basemod);
-        if(obj == null)
-        {
-            obj = new HashMap();
-        }
-        ((Map) (obj)).put(keybinding, new boolean[] {
-            flag
-        });
-        keyList.put(basemod, obj);
-    }
-
-    public static void RegisterTileEntity(Class class1, String s)
-    {
-        RegisterTileEntity(class1, s, null);
-    }
-
-    public static void RegisterTileEntity(Class class1, String s, TileEntitySpecialRenderer tileentityspecialrenderer)
-    {
-        try
-        {
-            method_RegisterTileEntity.invoke(null, new Object[] {
-                class1, s
-            });
-            if(tileentityspecialrenderer != null)
-            {
-                TileEntityRenderer tileentityrenderer = TileEntityRenderer.field_1554_a;
-                Map map = (Map)field_TileEntityRenderers.get(tileentityrenderer);
-                map.put(class1, tileentityspecialrenderer);
-                tileentityspecialrenderer.func_928_a(tileentityrenderer);
-            }
-        }
-        catch(IllegalArgumentException illegalargumentexception)
-        {
-            logger.throwing("ModLoader", "RegisterTileEntity", illegalargumentexception);
-            ThrowException(illegalargumentexception);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "RegisterTileEntity", illegalaccessexception);
-            ThrowException(illegalaccessexception);
-        }
-        catch(InvocationTargetException invocationtargetexception)
-        {
-            logger.throwing("ModLoader", "RegisterTileEntity", invocationtargetexception);
-            ThrowException(invocationtargetexception);
-        }
-    }
-
-    public static void RemoveSpawn(Class class1, EnumCreatureType enumcreaturetype)
-    {
-        RemoveSpawn(class1, enumcreaturetype, null);
-    }
-
-    public static void RemoveSpawn(Class class1, EnumCreatureType enumcreaturetype, BiomeGenBase abiomegenbase[])
-    {
-        if(class1 == null)
-        {
-            throw new IllegalArgumentException("entityClass cannot be null");
-        }
-        if(enumcreaturetype == null)
-        {
-            throw new IllegalArgumentException("spawnList cannot be null");
-        }
-        if(abiomegenbase == null)
-        {
-            abiomegenbase = standardBiomes;
-        }
-        for(int i = 0; i < abiomegenbase.length; i++)
-        {
-            List list = abiomegenbase[i].func_25063_a(enumcreaturetype);
-            if(list != null)
-            {
-                for(Iterator iterator = list.iterator(); iterator.hasNext();)
-                {
-                    SpawnListEntry spawnlistentry = (SpawnListEntry)iterator.next();
-                    if(spawnlistentry.field_25212_a == class1)
-                    {
-                        list.remove(spawnlistentry);
-                        break;
-                    }
-                }
-
-            }
-        }
-
-    }
-
-    public static void RemoveSpawn(String s, EnumCreatureType enumcreaturetype)
-    {
-        RemoveSpawn(s, enumcreaturetype, null);
-    }
-
-    public static void RemoveSpawn(String s, EnumCreatureType enumcreaturetype, BiomeGenBase abiomegenbase[])
-    {
-        Class class1 = (Class)classMap.get(s);
-        if(class1 != null && (net.minecraft.src.EntityLiving.class).isAssignableFrom(class1))
-        {
-            RemoveSpawn(class1, enumcreaturetype, abiomegenbase);
-        }
-    }
-
-    public static boolean RenderBlockIsItemFull3D(int i)
-    {
-        if(!blockSpecialInv.containsKey(Integer.valueOf(i)))
-        {
-            return i == 11;
-        } else
-        {
-            return ((Boolean)blockSpecialInv.get(Integer.valueOf(i))).booleanValue();
-        }
-    }
-
-    public static void RenderInvBlock(RenderBlocks renderblocks, Block block, int i, int j)
-    {
-        BaseMod basemod = (BaseMod)blockModels.get(Integer.valueOf(j));
-        if(basemod == null)
-        {
-            return;
-        } else
-        {
-            basemod.RenderInvBlock(renderblocks, block, i, j);
-            return;
-        }
-    }
-
-    public static boolean RenderWorldBlock(RenderBlocks renderblocks, IBlockAccess iblockaccess, int i, int j, int k, Block block, int l)
-    {
-        BaseMod basemod = (BaseMod)blockModels.get(Integer.valueOf(l));
-        if(basemod == null)
-        {
-            return false;
-        } else
-        {
-            return basemod.RenderWorldBlock(renderblocks, iblockaccess, i, j, k, block, l);
-        }
-    }
-
-    public static void saveConfig()
-        throws IOException
-    {
-        cfgdir.mkdir();
-        if(!cfgfile.exists() && !cfgfile.createNewFile())
-        {
-            return;
-        }
-        if(cfgfile.canWrite())
-        {
-            FileOutputStream fileoutputstream = new FileOutputStream(cfgfile);
-            props.store(fileoutputstream, "ModLoader Config");
-            fileoutputstream.close();
-        }
-    }
-
-    public static void SetInGameHook(BaseMod basemod, boolean flag, boolean flag1)
-    {
-        if(flag)
-        {
-            inGameHooks.put(basemod, Boolean.valueOf(flag1));
-        } else
-        {
-            inGameHooks.remove(basemod);
-        }
-    }
-
-    public static void SetInGUIHook(BaseMod basemod, boolean flag, boolean flag1)
-    {
-        if(flag)
-        {
-            inGUIHooks.put(basemod, Boolean.valueOf(flag1));
-        } else
-        {
-            inGUIHooks.remove(basemod);
-        }
-    }
-
-    public static void setPrivateValue(Class class1, Object obj, int i, Object obj1)
-        throws IllegalArgumentException, SecurityException, NoSuchFieldException
-    {
-        try
-        {
-            Field field = class1.getDeclaredFields()[i];
-            field.setAccessible(true);
-            int j = field_modifiers.getInt(field);
-            if((j & 0x10) != 0)
-            {
-                field_modifiers.setInt(field, j & 0xffffffef);
-            }
-            field.set(obj, obj1);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "setPrivateValue", illegalaccessexception);
-            ThrowException("An impossible error has occured!", illegalaccessexception);
-        }
-    }
-
-    public static void setPrivateValue(Class class1, Object obj, String s, Object obj1)
-        throws IllegalArgumentException, SecurityException, NoSuchFieldException
-    {
-        try
-        {
-            Field field = class1.getDeclaredField(s);
-            int i = field_modifiers.getInt(field);
-            if((i & 0x10) != 0)
-            {
-                field_modifiers.setInt(field, i & 0xffffffef);
-            }
-            field.setAccessible(true);
-            field.set(obj, obj1);
-        }
-        catch(IllegalAccessException illegalaccessexception)
-        {
-            logger.throwing("ModLoader", "setPrivateValue", illegalaccessexception);
-            ThrowException("An impossible error has occured!", illegalaccessexception);
-        }
-    }
-
-    public static void TakenFromCrafting(EntityPlayer entityplayer, ItemStack itemstack)
-    {
-        BaseMod basemod;
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext(); basemod.TakenFromCrafting(entityplayer, itemstack))
-        {
-            basemod = (BaseMod)iterator.next();
-        }
-
-    }
-
-    public static void TakenFromFurnace(EntityPlayer entityplayer, ItemStack itemstack)
-    {
-        BaseMod basemod;
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext(); basemod.TakenFromFurnace(entityplayer, itemstack))
-        {
-            basemod = (BaseMod)iterator.next();
-        }
-
-    }
-
-    public static void OnItemPickup(EntityPlayer entityplayer, ItemStack itemstack)
-    {
-        BaseMod basemod;
-        for(Iterator iterator = modList.values().iterator(); iterator.hasNext(); basemod.OnItemPickup(entityplayer, itemstack))
-        {
-            basemod = (BaseMod)iterator.next();
-        }
-
-    }
-
-    public static void ThrowException(String s, Throwable throwable)
-    {
-        Minecraft minecraft = getMinecraftInstance();
-        if(minecraft != null)
-        {
-            minecraft.func_4007_a(new UnexpectedThrowable(s, throwable));
-        } else
-        {
-            throw new RuntimeException(throwable);
-        }
-    }
-
-    private static void ThrowException(Throwable throwable)
-    {
-        ThrowException("Exception occured in ModLoader", throwable);
-    }
-
-    private static final List animList = new LinkedList();
-    private static final Map blockModels = new HashMap();
-    private static final Map blockSpecialInv = new HashMap();
-    private static final File cfgdir;
-    private static final File cfgfile;
-    public static Level cfgLoggingLevel;
-    private static Map classMap = null;
-    private static long clock = 0L;
-    public static final boolean DEBUG = false;
-    private static Field field_animList = null;
-    private static Field field_armorList = null;
-    private static Field field_blockList = null;
-    private static Field field_modifiers = null;
-    private static Field field_TileEntityRenderers = null;
-    private static boolean hasInit = false;
-    private static int highestEntityId = 3000;
-    private static final Map inGameHooks = new HashMap();
-    private static final Map inGUIHooks = new HashMap();
-    private static Minecraft instance = null;
-    private static int itemSpriteIndex = 0;
-    private static int itemSpritesLeft = 0;
-    private static final Map keyList = new HashMap();
-    private static final File logfile = new File(Minecraft.func_6240_b(), "ModLoader.txt");
-    private static final File modDir = new File(Minecraft.func_6240_b(), "/mods/");
-    private static final Logger logger = Logger.getLogger("ModLoader");
-    private static FileHandler logHandler = null;
-    private static Method method_RegisterEntityID = null;
-    private static Method method_RegisterTileEntity = null;
-    private static final Map modList = new HashMap();
-    private static int nextBlockModelID = 1000;
-    private static final Map overrides = new HashMap();
-    public static final Properties props = new Properties();
-    private static BiomeGenBase standardBiomes[];
-    private static int terrainSpriteIndex = 0;
-    private static int terrainSpritesLeft = 0;
-    private static String texPack = null;
-    private static boolean texturesAdded = false;
-    private static final boolean usedItemSprites[] = new boolean[256];
-    private static final boolean usedTerrainSprites[] = new boolean[256];
-    public static final String VERSION = "ModLoader Beta 1.6.6";
-
-    static 
-    {
-        cfgdir = new File(Minecraft.func_6240_b(), "/config/");
-        cfgfile = new File(cfgdir, "ModLoader.cfg");
-        cfgLoggingLevel = Level.FINER;
-    }
+	private static final List<TextureFX> animList = new LinkedList<TextureFX>();
+	private static final Map<Integer, BaseMod> blockModels = new HashMap<Integer, BaseMod>();
+	private static final Map<Integer, Boolean> blockSpecialInv = new HashMap<Integer, Boolean>();
+	private static final File cfgdir = new File(Minecraft.getMinecraftDir(), "/config/");
+	private static final File cfgfile = new File(cfgdir, "ModLoader.cfg");
+	public static Level cfgLoggingLevel = Level.FINER;
+	private static Map<String, Class<? extends Entity>> classMap = null;
+	private static long clock = 0L;
+	public static final boolean DEBUG = false;
+	private static Field field_animList = null;
+	private static Field field_armorList = null;
+	private static Field field_blockList = null;
+	private static Field field_modifiers = null;
+	private static Field field_TileEntityRenderers = null;
+	private static boolean hasInit = false;
+	private static int highestEntityId = 3000;
+	private static final Map<BaseMod, Boolean> inGameHooks = new HashMap<BaseMod, Boolean>();
+	private static final Map<BaseMod, Boolean> inGUIHooks = new HashMap<BaseMod, Boolean>();
+	private static Minecraft instance = null;
+	private static int itemSpriteIndex = 0;
+	private static int itemSpritesLeft = 0;
+	private static final Map<BaseMod, Map<KeyBinding, boolean[]>> keyList = new HashMap<BaseMod, Map<KeyBinding, boolean[]>>();
+	private static final File logfile = new File(Minecraft.getMinecraftDir(), "ModLoader.txt");
+	private static final File modDir = new File(Minecraft.getMinecraftDir(), "/mods/");
+	private static final Logger logger = Logger.getLogger("ModLoader");
+	private static FileHandler logHandler = null;
+	private static Method method_RegisterEntityID = null;
+	private static Method method_RegisterTileEntity = null;
+	private static final Map<String, BaseMod> modList = new HashMap<String, BaseMod>();
+	private static int nextBlockModelID = 1000;
+	private static final Map<Integer, Map<String, Integer>> overrides = new HashMap<Integer, Map<String, Integer>>();
+	public static final Properties props = new Properties();
+	private static BiomeGenBase[] standardBiomes;
+	private static int terrainSpriteIndex = 0;
+	private static int terrainSpritesLeft = 0;
+	private static String texPack = null;
+	private static boolean texturesAdded = false;
+	private static final boolean[] usedItemSprites = new boolean[256];
+	private static final boolean[] usedTerrainSprites = new boolean[256];
+	public static final String VERSION = "ModLoader Beta 1.6.6";
+
+	public ModLoader()
+	{
+	}
+
+	public static void AddAchievementDesc(Achievement achievement, String name, String description)
+	{
+		try
+		{
+			if(achievement.statName.contains("."))
+			{
+				String key = achievement.statName.split("\\.")[1];
+				AddLocalization("achievement." + key, name);
+				AddLocalization((new StringBuilder("achievement.")).append(key).append(".desc").toString(), description);
+				setPrivateValue(StatBase.class, achievement, 1, StatCollector.translateToLocal("achievement." + key));
+				setPrivateValue(Achievement.class, achievement, 3, StatCollector.translateToLocal((new StringBuilder("achievement.")).append(key).append(".desc").toString()));
+			} else
+			{
+				setPrivateValue(StatBase.class, achievement, 1, name);
+				setPrivateValue(Achievement.class, achievement, 3, description);
+			}
+		}
+		catch(IllegalArgumentException e)
+		{
+			logger.throwing("ModLoader", "AddAchievementDesc", e);
+			ThrowException(e);
+		}
+		catch(SecurityException e)
+		{
+			logger.throwing("ModLoader", "AddAchievementDesc", e);
+			ThrowException(e);
+		}
+		catch(NoSuchFieldException e)
+		{
+			logger.throwing("ModLoader", "AddAchievementDesc", e);
+			ThrowException(e);
+		}
+	}
+
+	public static int AddAllFuel(int id)
+	{
+		logger.finest("Finding fuel for " + id);
+		int result = 0;
+		for (BaseMod mod : modList.values())
+		{
+			if ((result = mod.AddFuel(id)) == 0)
+			{
+				logger.finest("Returned " + result);
+				break;
+			}
+		}
+		return result;
+	}
+
+	public static void AddAllRenderers(Map<Class<? extends Entity>, Render> o)
+	{
+		if(!hasInit)
+		{
+			init();
+			logger.fine("Initialized");
+		}
+
+		for (BaseMod mod : modList.values())
+			mod.AddRenderer(o);
+	}
+
+	public static void addAnimation(TextureFX anim)
+	{
+		logger.finest("Adding animation " + anim.toString());
+		for (TextureFX oldAnim : animList)
+		{
+			if (oldAnim.iconIndex == anim.iconIndex)
+			{
+				animList.remove(anim);
+				break;
+			}
+		}
+		animList.add(anim);
+	}
+
+	public static int AddArmor(String armor)
+	{
+		try
+		{
+			String[] existingArmor = (String[])field_armorList.get(null);
+			List<String> existingArmorList = Arrays.asList(existingArmor);
+			List<String> combinedList = new ArrayList<String>();
+			combinedList.addAll(existingArmorList);
+			if (!combinedList.contains(armor))
+				combinedList.add(armor);
+			int index = combinedList.indexOf(armor);
+			field_armorList.set(null, combinedList.toArray(new String[0]));
+			return index;
+		} catch (IllegalArgumentException e) {
+			logger.throwing("ModLoader", "AddArmor", e);
+			ThrowException("An impossible error has occured!", e);
+		} catch (IllegalAccessException e) {
+			logger.throwing("ModLoader", "AddArmor", e);
+			ThrowException("An impossible error has occured!", e);
+		}
+		return -1;
+	}
+
+	public static void AddLocalization(String key, String value)
+	{
+		Properties props = null;
+		try {
+			props = (Properties)getPrivateValue(StringTranslate.class, StringTranslate.getInstance(), 1);
+		} catch (SecurityException e) {
+			logger.throwing("ModLoader", "AddLocalization", e);
+			ThrowException(e);
+		} catch (NoSuchFieldException e) {
+			logger.throwing("ModLoader", "AddLocalization", e);
+			ThrowException(e);
+		}
+		if (props != null)
+			props.put(key, value);
+	}
+
+	private static void addMod(ClassLoader classLoader, String className, String classFullName)
+	{
+		try
+		{
+			classFullName = classFullName.substring(0, classFullName.lastIndexOf('.'));
+			if(!classFullName.contains("$") && (!props.containsKey(className) || (!props.getProperty(className).equalsIgnoreCase("no") && !props.getProperty(className).equalsIgnoreCase("off"))))
+			{
+				Class modClass = classLoader.loadClass(classFullName);
+				if(BaseMod.class.isAssignableFrom(modClass))
+				{
+					setupProperties(modClass);
+					BaseMod mod = (BaseMod)modClass.newInstance();
+					String modName = mod.toString();
+					if(mod != null && !modList.containsKey(modName))
+					{
+						modList.put(modName, mod);
+						logger.fine((new StringBuilder("Mod Loaded: \"")).append(modName).append("\" from ").append(className).toString());
+						System.out.println("Mod Loaded: " + modName);
+					}
+				}
+			}
+		}
+		catch(Throwable e)
+		{
+			logger.fine((new StringBuilder("Failed to load mod from \"")).append(className).append("\"").toString());
+			System.out.println((new StringBuilder("Failed to load mod from \"")).append(className).append("\"").toString());
+			logger.throwing("ModLoader", "addMod", e);
+			ThrowException(e);
+		}
+	}
+
+	private static void setupProperties(Class<? extends BaseMod> mod) throws IllegalArgumentException, IllegalAccessException, IOException, SecurityException, NoSuchFieldException
+	{
+		Properties modprops = new Properties();
+
+		File modcfgfile = new File(cfgdir, mod.getName() + ".cfg");
+		if ((modcfgfile.exists()) && (modcfgfile.canRead())) {
+			modprops.load(new FileInputStream(modcfgfile));
+		}
+		StringBuilder helptext = new StringBuilder();
+
+		for (Field field : mod.getFields()) {
+			if (((field.getModifiers() & 0x8) != 0) && (field.isAnnotationPresent(MLProp.class))) {
+				Class type = field.getType();
+				MLProp annotation = field.getAnnotation(MLProp.class);
+				String key = annotation.name().length() == 0 ? field.getName() : annotation.name();
+				Object currentvalue = field.get(null);
+
+				StringBuilder range = new StringBuilder();
+				if (annotation.min() != (-1.0D / 0.0D))
+					range.append(String.format(",>=%.1f", new Object[] { Double.valueOf(annotation.min()) }));
+				if (annotation.max() != (1.0D / 0.0D)) {
+					range.append(String.format(",<=%.1f", new Object[] { Double.valueOf(annotation.max()) }));
+				}
+				StringBuilder info = new StringBuilder();
+				if (annotation.info().length() > 0) {
+					info.append(" -- ");
+					info.append(annotation.info());
+				}
+
+				helptext.append(String.format("%s (%s:%s%s)%s\n", new Object[] { key, type.getName(), currentvalue, range, info }));
+
+				if (modprops.containsKey(key)) {
+					String strvalue = modprops.getProperty(key);
+
+					Object value = null;
+					if (type.isAssignableFrom(String.class)) value = strvalue;
+					else if (type.isAssignableFrom(Integer.TYPE)) value = Integer.valueOf(Integer.parseInt(strvalue));
+					else if (type.isAssignableFrom(Short.TYPE)) value = Short.valueOf(Short.parseShort(strvalue));
+					else if (type.isAssignableFrom(Byte.TYPE)) value = Byte.valueOf(Byte.parseByte(strvalue));
+					else if (type.isAssignableFrom(Boolean.TYPE)) value = Boolean.valueOf(Boolean.parseBoolean(strvalue));
+					else if (type.isAssignableFrom(Float.TYPE)) value = Float.valueOf(Float.parseFloat(strvalue));
+					else if (type.isAssignableFrom(Double.TYPE)) {
+						value = Double.valueOf(Double.parseDouble(strvalue));
+					}
+					if (value != null) {
+						if ((value instanceof Number)) {
+							double num = ((Number)value).doubleValue();
+							if ((annotation.min() != (-1.0D / 0.0D)) && (num < annotation.min()))
+								continue;
+							if ((annotation.max() != (1.0D / 0.0D)) && (num > annotation.max())) {
+								continue;
+							}
+						}
+						logger.finer(key + " set to " + value);
+						if (!value.equals(currentvalue))
+							field.set(null, value);
+					}
+				} else {
+					logger.finer(key + " not in config, using default: " + currentvalue);
+					modprops.setProperty(key, currentvalue.toString());
+				}
+			}
+		}
+
+		if ((!modprops.isEmpty()) && ((modcfgfile.exists()) || (modcfgfile.createNewFile())) && (modcfgfile.canWrite()))
+			modprops.store(new FileOutputStream(modcfgfile), helptext.toString());
+	}
+
+	public static void AddName(Object instance, String name)
+	{
+		String tag = null;
+		if ((instance instanceof Item)) {
+			Item item = (Item)instance;
+			if (item.getItemName() != null)
+				tag = item.getItemName() + ".name";
+		} else if ((instance instanceof Block)) {
+			Block block = (Block)instance;
+			if (block.getBlockName() != null)
+				tag = block.getBlockName() + ".name";
+		} else if ((instance instanceof ItemStack)) {
+			ItemStack stack = (ItemStack)instance;
+			if (stack.getItemName() != null)
+				tag = stack.getItemName() + ".name";
+		} else {
+			Exception e = new Exception(instance.getClass().getName() + " cannot have name attached to it!");
+			logger.throwing("ModLoader", "AddName", e);
+			ThrowException(e);
+		}
+		if (tag != null) { 
+			AddLocalization(tag, name);
+		} else {
+			Exception e = new Exception(instance + " is missing name tag!");
+			logger.throwing("ModLoader", "AddName", e);
+			ThrowException(e);
+		}
+	}
+
+	public static int addOverride(String fileToOverride, String fileToAdd)
+	{
+		try
+		{
+			int i = getUniqueSpriteIndex(fileToOverride);
+			addOverride(fileToOverride, fileToAdd, i);
+			return i;
+		} catch (Throwable e) {
+			logger.throwing("ModLoader", "addOverride", e);
+			ThrowException(e);
+			throw new RuntimeException(e);
+		}
+	}
+
+	public static void addOverride(String path, String overlayPath, int index)
+	{
+		int dst = -1;
+		int left = 0;
+		if (path.equals("/terrain.png")) {
+			dst = 0;
+			left = terrainSpritesLeft;
+		} else if (path.equals("/gui/items.png")) {
+			dst = 1;
+			left = itemSpritesLeft; } else {
+				return;
+			}System.out.println("Overriding " + path + " with " + overlayPath + " @ " + index + ". " + left + " left.");
+			logger.finer("addOverride(" + path + "," + overlayPath + "," + index + "). " + left + " left.");
+			Map<String, Integer> overlays = overrides.get(Integer.valueOf(dst));
+			if (overlays == null) {
+				overlays = new HashMap<String, Integer>();
+				overrides.put(Integer.valueOf(dst), overlays);
+			}
+			overlays.put(overlayPath, Integer.valueOf(index));
+	}
+
+	public static void AddRecipe(ItemStack output, Object[] params)
+	{
+		CraftingManager.getInstance().addRecipe(output, params);
+	}
+
+	public static void AddShapelessRecipe(ItemStack output, Object[] params)
+	{
+		CraftingManager.getInstance().addShapelessRecipe(output, params);
+	}
+
+	public static void AddSmelting(int input, ItemStack output)
+	{
+		FurnaceRecipes.smelting().addSmelting(input, output);
+	}
+
+	public static void AddSpawn(Class<? extends EntityLiving> entityClass, int weightedProb, EnumCreatureType spawnList)
+	{
+		AddSpawn(entityClass, weightedProb, spawnList, null);
+	}
+
+	public static void AddSpawn(Class<? extends EntityLiving> entityClass, int weightedProb, EnumCreatureType spawnList, BiomeGenBase[] biomes)
+	{
+		if(entityClass == null)
+		{
+			throw new IllegalArgumentException("entityClass cannot be null");
+		}
+		if(spawnList == null)
+		{
+			throw new IllegalArgumentException("spawnList cannot be null");
+		}
+		if(biomes == null)
+		{
+			biomes = standardBiomes;
+		}
+		for(int j = 0; j < biomes.length; j++)
+		{
+			List<SpawnListEntry> list = biomes[j].getSpawnableList(spawnList);
+
+			if (list != null) {
+				boolean exists = false;
+				for (SpawnListEntry entry : list) {
+					if (entry.entityClass == entityClass) {
+						entry.spawnRarityRate = weightedProb;
+						exists = true;
+						break;
+					}
+				}
+				if (!exists)
+					list.add(new SpawnListEntry(entityClass, weightedProb));
+			}
+		}
+	}
+
+	public static void AddSpawn(String entityName, int weightedProb, EnumCreatureType spawnList)
+	{
+		AddSpawn(entityName, weightedProb, spawnList, null);
+	}
+
+	public static void AddSpawn(String entityName, int weightedProb, EnumCreatureType spawnList, BiomeGenBase[] biomes)
+	{
+		Class class1 = (Class)classMap.get(entityName);
+		if(class1 != null && (EntityLiving.class).isAssignableFrom(class1))
+		{
+			AddSpawn(class1, weightedProb, spawnList, biomes);
+		}
+	}
+
+	public static boolean DispenseEntity(World world, double x, double y, double z, int xVel, int zVel, ItemStack item)
+	{
+		for (BaseMod mod : modList.values())
+			if (mod.DispenseEntity(world, x, y, z, xVel, zVel, item))
+				return true;
+		return false;
+	}
+
+	public static List<BaseMod> getLoadedMods()
+	{
+		return Collections.unmodifiableList(new LinkedList<BaseMod>(modList.values()));
+	}
+
+	public static Logger getLogger()
+	{
+		return logger;
+	}
+
+	public static Minecraft getMinecraftInstance()
+	{
+		if (instance == null) {
+			try {
+				ThreadGroup group = Thread.currentThread().getThreadGroup();
+				int count = group.activeCount();
+				Thread[] threads = new Thread[count];
+				group.enumerate(threads);
+				for (Thread thread : threads)
+					if (thread.getName().equals("Minecraft main thread")) {
+						instance = (Minecraft)getPrivateValue(Thread.class, thread, "target");
+						break;
+					}
+			}
+			catch (SecurityException e) {
+				logger.throwing("ModLoader", "getMinecraftInstance", e);
+				throw new RuntimeException(e);
+			} catch (NoSuchFieldException e) {
+				logger.throwing("ModLoader", "getMinecraftInstance", e);
+				throw new RuntimeException(e);
+			}
+		}
+		return instance;
+	}
+
+	public static <T, E> T getPrivateValue(Class<? super E> instanceclass, E instance, int fieldindex)
+	throws IllegalArgumentException, SecurityException, NoSuchFieldException
+	{
+		try
+		{
+			Field f = instanceclass.getDeclaredFields()[fieldindex];
+			f.setAccessible(true);
+			return (T)f.get(instance);
+		} catch (IllegalAccessException e) {
+			logger.throwing("ModLoader", "getPrivateValue", e);
+			ThrowException("An impossible error has occured!", e);
+		}
+		return null;
+	}
+
+	public static <T, E> T getPrivateValue(Class<? super E> instanceclass, E instance, String field)
+	throws IllegalArgumentException, SecurityException, NoSuchFieldException
+	{
+		try
+		{
+			Field f = instanceclass.getDeclaredField(field);
+			f.setAccessible(true);
+			return (T)f.get(instance);
+		} catch (IllegalAccessException e) {
+			logger.throwing("ModLoader", "getPrivateValue", e);
+			ThrowException("An impossible error has occured!", e);
+		}
+		return null;
+	}
+
+	public static int getUniqueBlockModelID(BaseMod basemod, boolean flag)
+	{
+		int i = nextBlockModelID++;
+		blockModels.put(Integer.valueOf(i), basemod);
+		blockSpecialInv.put(Integer.valueOf(i), Boolean.valueOf(flag));
+		return i;
+	}
+
+	public static int getUniqueEntityId()
+	{
+		return highestEntityId++;
+	}
+
+	private static int getUniqueItemSpriteIndex()
+	{
+		for(; itemSpriteIndex < usedItemSprites.length; itemSpriteIndex++)
+		{
+			if(!usedItemSprites[itemSpriteIndex])
+			{
+				usedItemSprites[itemSpriteIndex] = true;
+				itemSpritesLeft--;
+				return itemSpriteIndex++;
+			}
+		}
+
+		Exception exception = new Exception("No more empty item sprite indices left!");
+		logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
+		ThrowException(exception);
+		return 0;
+	}
+
+	public static int getUniqueSpriteIndex(String s)
+	{
+		if(s.equals("/gui/items.png"))
+		{
+			return getUniqueItemSpriteIndex();
+		}
+		if(s.equals("/terrain.png"))
+		{
+			return getUniqueTerrainSpriteIndex();
+		} else
+		{
+			Exception exception = new Exception("No registry for this texture: " + s);
+			logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
+			ThrowException(exception);
+			return 0;
+		}
+	}
+
+	private static int getUniqueTerrainSpriteIndex()
+	{
+		for(; terrainSpriteIndex < usedTerrainSprites.length; terrainSpriteIndex++)
+		{
+			if(!usedTerrainSprites[terrainSpriteIndex])
+			{
+				usedTerrainSprites[terrainSpriteIndex] = true;
+				terrainSpritesLeft--;
+				return terrainSpriteIndex++;
+			}
+		}
+
+		Exception exception = new Exception("No more empty terrain sprite indices left!");
+		logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
+		ThrowException(exception);
+		return 0;
+	}
+
+	private static void init()
+	{
+		hasInit = true;
+		String usedItemSpritesString = "1111111111111111111111111111111111111101111111011111111111111001111111111111111111111111111010111111100110000011111110000000001111111001100000110000000100000011000000010000001100000000000000110000000000000000000000000000000000000000000000001100000000000000";
+		String usedTerrainSpritesString = "1111111111111111111111111111110111111111111111111111110111111111111111111111000111111011111111111111001111000000111111111111100011111111000010001111011110000000111111000000000011111100000000001111000000000111111000000000001101000000000001111111111111000011";
+		for(int i = 0; i < 256; i++)
+		{
+			usedItemSprites[i] = usedItemSpritesString.charAt(i) == '1';
+			if(!usedItemSprites[i])
+			{
+				itemSpritesLeft++;
+			}
+			usedTerrainSprites[i] = usedTerrainSpritesString.charAt(i) == '1';
+			if(!usedTerrainSprites[i])
+			{
+				terrainSpritesLeft++;
+			}
+		}
+
+		try
+		{
+			instance = (Minecraft)getPrivateValue(Minecraft.class, null, 1);
+			instance.entityRenderer = new EntityRendererProxy(instance);
+			classMap = (Map<String, Class<? extends Entity>>)getPrivateValue(EntityList.class, null, 0);
+			field_modifiers = (Field.class).getDeclaredField("modifiers");
+			field_modifiers.setAccessible(true);
+			field_blockList = (Session.class).getDeclaredFields()[0];
+			field_blockList.setAccessible(true);
+			field_TileEntityRenderers = (TileEntityRenderer.class).getDeclaredFields()[0];
+			field_TileEntityRenderers.setAccessible(true);
+			field_armorList = (RenderPlayer.class).getDeclaredFields()[3];
+			field_modifiers.setInt(field_armorList, field_armorList.getModifiers() & 0xffffffef);
+			field_armorList.setAccessible(true);
+			field_animList = (RenderEngine.class).getDeclaredFields()[5];
+			field_animList.setAccessible(true);
+			Field afield[] = (BiomeGenBase.class).getDeclaredFields();
+			LinkedList<BiomeGenBase> linkedlist = new LinkedList<BiomeGenBase>();
+			for(int j = 0; j < afield.length; j++)
+			{
+				Class class1 = afield[j].getType();
+				if((afield[j].getModifiers() & 8) != 0 && class1.isAssignableFrom(BiomeGenBase.class))
+				{
+					BiomeGenBase biomegenbase = (BiomeGenBase)afield[j].get(null);
+					if(!(biomegenbase instanceof BiomeGenHell))
+					{
+						linkedlist.add(biomegenbase);
+					}
+				}
+			}
+
+			standardBiomes = linkedlist.toArray(new BiomeGenBase[0]);
+			try
+			{
+				method_RegisterTileEntity = (TileEntity.class).getDeclaredMethod("a", new Class[] {
+						java.lang.Class.class, java.lang.String.class
+				});
+			}
+			catch(NoSuchMethodException e)
+			{
+				method_RegisterTileEntity = (TileEntity.class).getDeclaredMethod("addMapping", new Class[] {
+						java.lang.Class.class, java.lang.String.class
+				});
+			}
+			method_RegisterTileEntity.setAccessible(true);
+			try
+			{
+				method_RegisterEntityID = (EntityList.class).getDeclaredMethod("a", new Class[] {
+						java.lang.Class.class, java.lang.String.class, Integer.TYPE
+				});
+			}
+			catch(NoSuchMethodException e)
+			{
+				method_RegisterEntityID = (EntityList.class).getDeclaredMethod("addMapping", new Class[] {
+						java.lang.Class.class, java.lang.String.class, Integer.TYPE
+				});
+			}
+			method_RegisterEntityID.setAccessible(true);
+		}
+		catch(SecurityException e)
+		{
+			logger.throwing("ModLoader", "init", e);
+			ThrowException(e);
+			throw new RuntimeException(e);
+		}
+		catch(NoSuchFieldException e)
+		{
+			logger.throwing("ModLoader", "init", e);
+			ThrowException(e);
+			throw new RuntimeException(e);
+		}
+		catch(NoSuchMethodException e)
+		{
+			logger.throwing("ModLoader", "init", e);
+			ThrowException(e);
+			throw new RuntimeException(e);
+		}
+		catch(IllegalArgumentException e)
+		{
+			logger.throwing("ModLoader", "init", e);
+			ThrowException(e);
+			throw new RuntimeException(e);
+		}
+		catch(IllegalAccessException e)
+		{
+			logger.throwing("ModLoader", "init", e);
+			ThrowException(e);
+			throw new RuntimeException(e);
+		}
+		try
+		{
+			loadConfig();
+			if(props.containsKey("loggingLevel"))
+			{
+				cfgLoggingLevel = Level.parse(props.getProperty("loggingLevel"));
+			}
+			if(props.containsKey("grassFix"))
+			{
+				RenderBlocks.cfgGrassFix = Boolean.parseBoolean(props.getProperty("grassFix"));
+			}
+			logger.setLevel(cfgLoggingLevel);
+			if((logfile.exists() || logfile.createNewFile()) && logfile.canWrite() && logHandler == null)
+			{
+				logHandler = new FileHandler(logfile.getPath());
+				logHandler.setFormatter(new SimpleFormatter());
+				logger.addHandler(logHandler);
+			}
+			logger.fine("ModLoader Beta 1.6.6 Initializing...");
+			System.out.println("ModLoader Beta 1.6.6 Initializing...");
+			File source = new File((ModLoader.class).getProtectionDomain().getCodeSource().getLocation().toURI());
+			modDir.mkdirs();
+			readFromModFolder(modDir);
+			readFromClassPath(source);
+			System.out.println("Done.");
+			props.setProperty("loggingLevel", cfgLoggingLevel.getName());
+			props.setProperty("grassFix", Boolean.toString(RenderBlocks.cfgGrassFix));
+
+			for (BaseMod mod : modList.values()) {
+				mod.ModsLoaded();
+				if (!props.containsKey(mod.getClass().getName())) {
+					props.setProperty(mod.getClass().getName(), "on");
+				}
+			}
+
+			initStats();
+			saveConfig();
+		}
+		catch(Throwable throwable)
+		{
+			logger.throwing("ModLoader", "init", throwable);
+			ThrowException("ModLoader has failed to initialize.", throwable);
+			if(logHandler != null)
+			{
+				logHandler.close();
+			}
+			throw new RuntimeException(throwable);
+		}
+	}
+
+	private static void initStats()
+	{
+		for(int i = 0; i < Block.blocksList.length; i++)
+		{
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1000000 + i)) && Block.blocksList[i] != null && Block.blocksList[i].getEnableStats())
+			{
+				String s = StatCollector.translateToLocalFormatted("stat.mineBlock", new Object[] {
+						Block.blocksList[i].func_25016_i()
+				});
+				StatList.mineBlockStatArray[i] = (new StatCrafting(0x1000000 + i, s, i)).registerStat();
+				StatList.field_25185_d.add(StatList.mineBlockStatArray[i]);
+			}
+		}
+
+		for(int j = 0; j < Item.itemsList.length; j++)
+		{
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1020000 + j)) && Item.itemsList[j] != null)
+			{
+				String s1 = StatCollector.translateToLocalFormatted("stat.useItem", new Object[] {
+						Item.itemsList[j].getStatName()
+				});
+				StatList.field_25172_A[j] = (new StatCrafting(0x1020000 + j, s1, j)).registerStat();
+				if(j >= Block.blocksList.length)
+				{
+					StatList.field_25186_c.add(StatList.field_25172_A[j]);
+				}
+			}
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1030000 + j)) && Item.itemsList[j] != null && Item.itemsList[j].isDamagable())
+			{
+				String s2 = StatCollector.translateToLocalFormatted("stat.breakItem", new Object[] {
+						Item.itemsList[j].getStatName()
+				});
+				StatList.field_25170_B[j] = (new StatCrafting(0x1030000 + j, s2, j)).registerStat();
+			}
+		}
+
+		HashSet<Integer> idHashSet = new HashSet<Integer>();
+
+		for (Object result : CraftingManager.getInstance().getRecipeList())
+			idHashSet.add(Integer.valueOf(((IRecipe)result).func_25117_b().itemID));
+		for (Object result : FurnaceRecipes.smelting().getSmeltingList().values())
+			idHashSet.add(Integer.valueOf(((ItemStack)result).itemID));
+
+		for (int id : idHashSet) {
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(0x1010000 + id)) && Item.itemsList[id] != null)
+			{
+				String s3 = StatCollector.translateToLocalFormatted("stat.craftItem", new Object[] {
+						Item.itemsList[id].getStatName()
+				});
+				StatList.field_25158_z[id] = (new StatCrafting(0x1010000 + id, s3, id)).registerStat();
+			}
+		}
+	}
+
+	public static boolean isGUIOpen(Class<? extends GuiScreen> gui)
+	{
+		Minecraft minecraft = getMinecraftInstance();
+		if(gui == null)
+		{
+			return minecraft.currentScreen == null;
+		}
+		if(minecraft.currentScreen == null && gui != null)
+		{
+			return false;
+		} else
+		{
+			return gui.isInstance(minecraft.currentScreen);
+		}
+	}
+
+	public static boolean isModLoaded(String modname)
+	{
+		Class chk = null;
+		try {
+			chk = Class.forName(modname);
+		} catch (ClassNotFoundException e) {
+			return false;
+		}
+		if (chk != null) {
+			for (BaseMod mod : modList.values()) {
+				if (chk.isInstance(mod))
+					return true;
+			}
+		}
+		return false;
+	}
+
+	public static void loadConfig()
+	throws IOException
+	{
+		cfgdir.mkdir();
+		if(!cfgfile.exists() && !cfgfile.createNewFile())
+		{
+			return;
+		}
+		if(cfgfile.canRead())
+		{
+			FileInputStream fileinputstream = new FileInputStream(cfgfile);
+			props.load(fileinputstream);
+			fileinputstream.close();
+		}
+	}
+
+	public static BufferedImage loadImage(RenderEngine texCache, String path)
+	throws Exception
+	{
+		TexturePackList texturepacklist = (TexturePackList)getPrivateValue(RenderEngine.class, texCache, 11);
+		InputStream inputstream = texturepacklist.selectedTexturePack.getResourceAsStream(path);
+		if(inputstream == null)
+		{
+			throw new Exception("Image not found: " + path);
+		}
+		BufferedImage bufferedimage = ImageIO.read(inputstream);
+		if(bufferedimage == null)
+		{
+			throw new Exception("Image not found: " + path);
+		} else
+		{
+			return bufferedimage;
+		}
+	}
+
+	public static void OnTick(Minecraft game)
+	{
+		if(!hasInit)
+		{
+			init();
+			logger.fine("Initialized");
+		}
+		if(texPack == null || game.gameSettings.skin != texPack)
+		{
+			texturesAdded = false;
+			texPack = game.gameSettings.skin;
+		}
+		if(!texturesAdded && game.renderEngine != null)
+		{
+			RegisterAllTextureOverrides(game.renderEngine);
+			texturesAdded = true;
+		}
+		long newclock = 0L;
+		if(game.theWorld != null)
+		{
+			newclock = game.theWorld.getWorldTime();
+			for (Map.Entry<BaseMod, Boolean> modSet : inGameHooks.entrySet())
+				if ((clock == newclock) && (modSet.getValue().booleanValue()))
+					modSet.getKey().OnTickInGame(game);
+
+		}
+		if(game.currentScreen != null)
+		{
+			for (Map.Entry<BaseMod, Boolean> modSet : inGUIHooks.entrySet())
+				if(clock != newclock || !(modSet.getValue().booleanValue() & (game.theWorld != null)))
+					modSet.getKey().OnTickInGUI(game, game.currentScreen);
+		}
+		if(clock != newclock)
+		{
+			for (Map.Entry<BaseMod, Map<KeyBinding, boolean[]>> modSet : keyList.entrySet()) {
+				for (Map.Entry<KeyBinding, boolean[]> keySet : modSet.getValue().entrySet()) {
+					boolean state = Keyboard.isKeyDown(keySet.getKey().keyCode);
+					boolean[] keyInfo = keySet.getValue();
+					boolean oldState = keyInfo[1];
+					keyInfo[1] = state;
+					if ((!state) || ((oldState) && (!keyInfo[0])))
+						continue;
+					modSet.getKey().KeyboardEvent(keySet.getKey());
+				}
+			}
+		}
+		clock = newclock;
+	}
+
+	public static void OpenGUI(EntityPlayer player, GuiScreen gui)
+	{
+		if(!hasInit)
+		{
+			init();
+			logger.fine("Initialized");
+		}
+		Minecraft minecraft = getMinecraftInstance();
+		if(minecraft.thePlayer != player)
+		{
+			return;
+		}
+		if(gui != null)
+		{
+			minecraft.displayGuiScreen(gui);
+		}
+	}
+
+	public static void PopulateChunk(IChunkProvider generator, int chunkX, int chunkZ, World world)
+	{
+		if(!hasInit)
+		{
+			init();
+			logger.fine("Initialized");
+		}
+		for (BaseMod mod : modList.values())
+		{
+			if (generator.makeString().equals("RandomLevelSource")) mod.GenerateSurface(world, world.rand, chunkX, chunkZ);
+			else if (generator.makeString().equals("HellRandomLevelSource"))
+				mod.GenerateNether(world, world.rand, chunkX, chunkZ);
+		}
+	}
+
+	private static void readFromModFolder(File folder)
+	throws IOException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, SecurityException, NoSuchMethodException
+	{
+		if(!folder.isDirectory())
+			throw new IllegalArgumentException("folder must be a Directory.");
+		logger.finer((new StringBuilder("Adding mods from ")).append(folder.getCanonicalPath()).toString());
+		System.out.println((new StringBuilder("Adding mods from ")).append(folder.getCanonicalPath()).toString());
+		readFromFileRecursive(folder, folder);
+	}
+
+	private static void readFromClassPath(File file)
+	throws FileNotFoundException, IOException
+	{
+		logger.finer((new StringBuilder("Adding mods from ")).append(file.getCanonicalPath()).toString());
+		System.out.println((new StringBuilder("Adding mods from ")).append(file.getCanonicalPath()).toString());
+		readFromFileRecursive(file, file.isDirectory() ? file : file.getParentFile());
+	}
+
+	private static void readFromFileRecursive(File file, File folder)
+	throws FileNotFoundException, IOException
+	{
+		if(file.isDirectory())
+			for (File subfFile : file.listFiles())
+				readFromFileRecursive(subfFile, folder);
+		else if(file.isFile())
+		{
+			String fileName = file.getName();
+			if (fileName.endsWith(".jar") || fileName.endsWith(".zip"))
+			{
+				logger.finer("Archive found : " + fileName);
+				ZipInputStream zipinputstream = new ZipInputStream(new BufferedInputStream(new FileInputStream(file)));
+				try
+				{
+					for (ZipEntry entry = zipinputstream.getNextEntry(); entry != null; entry = zipinputstream.getNextEntry())
+					{
+						String entryName = entry.getName();
+						String className = entryName.substring(entryName.lastIndexOf('/') + 1, entryName.length());
+						if(!entry.isDirectory() && className.startsWith("mod_") && className.endsWith(".class"))
+							addMod(new URLClassLoader(new URL[] { folder.toURI().toURL() }), className, entryName.replace('/', '.'));
+					}
+				}
+				finally
+				{
+					zipinputstream.close();
+				}
+			}
+			else if(fileName.startsWith("mod_") && fileName.endsWith(".class"))
+				addMod(new URLClassLoader(new URL[] { folder.toURI().toURL() }), fileName, file.getAbsolutePath().replace(folder.getAbsolutePath() + "\\", "").replace('\\', '.'));
+		}
+	}
+
+	public static KeyBinding[] RegisterAllKeys(KeyBinding[] akeybinding)
+	{
+		List<KeyBinding> existingKeyList = Arrays.asList(akeybinding);
+		List<KeyBinding> combinedList = new ArrayList<KeyBinding>();
+		combinedList.addAll(existingKeyList);
+		for (Map<KeyBinding, boolean[]> keyMap : keyList.values())
+			combinedList.addAll(keyMap.keySet());
+		return combinedList.toArray(new KeyBinding[0]);
+	}
+
+	public static void RegisterAllTextureOverrides(RenderEngine texCache)
+	{
+		animList.clear();
+		Minecraft game = getMinecraftInstance();
+		for (BaseMod mod : modList.values())
+			mod.RegisterAnimation(game);
+		for (TextureFX anim : animList)
+			texCache.registerTextureFX(anim);
+
+		for (Map.Entry<Integer, Map<String, Integer>> overlay : overrides.entrySet())
+			for (Map.Entry<String, Integer> overlayEntry : overlay.getValue().entrySet()) {
+				String overlayPath = overlayEntry.getKey();
+				int index = overlayEntry.getValue().intValue();
+				int dst = overlay.getKey().intValue();
+				String dstPath = null;
+				if (dst == 0) dstPath = "/terrain.png";
+				else if (dst == 1) dstPath = "/gui/items.png"; else
+					throw new ArrayIndexOutOfBoundsException(dst);
+				try {
+					BufferedImage im = loadImage(texCache, overlayPath);
+					ModTextureStatic anim = new ModTextureStatic(index, dst, im);
+
+					texCache.registerTextureFX(anim);
+				} catch (Exception e) {
+					logger.throwing("ModLoader", "RegisterAllTextureOverrides", e);
+					ThrowException(e);
+					throw new RuntimeException(e);
+				}
+			}
+	}
+
+	public static void RegisterBlock(Block block)
+	{
+		RegisterBlock(block, null);
+	}
+
+	public static void RegisterBlock(Block block, Class<? extends ItemBlock> class1)
+	{
+		try
+		{
+			if(block == null)
+			{
+				throw new IllegalArgumentException("block parameter cannot be null.");
+			}
+			List<Block> list = (List<Block>)field_blockList.get(null);
+			list.add(block);
+			int id = block.blockID;
+			ItemBlock item = null;
+			if(class1 != null)
+				item = (ItemBlock)class1.getConstructor(new Class[] { Integer.TYPE }).newInstance(new Object[] { Integer.valueOf(id - 256) });
+			else
+				item = new ItemBlock(id - 256);
+			if(Block.blocksList[id] != null && Item.itemsList[id] == null)
+				Item.itemsList[id] = item;
+		}
+		catch(IllegalArgumentException e)
+		{
+			logger.throwing("ModLoader", "RegisterBlock", e);
+			ThrowException(e);
+		}
+		catch(IllegalAccessException e)
+		{
+			logger.throwing("ModLoader", "RegisterBlock", e);
+			ThrowException(e);
+		}
+		catch(SecurityException e)
+		{
+			logger.throwing("ModLoader", "RegisterBlock", e);
+			ThrowException(e);
+		}
+		catch(InstantiationException e)
+		{
+			logger.throwing("ModLoader", "RegisterBlock", e);
+			ThrowException(e);
+		}
+		catch(InvocationTargetException e)
+		{
+			logger.throwing("ModLoader", "RegisterBlock", e);
+			ThrowException(e);
+		}
+		catch(NoSuchMethodException e)
+		{
+			logger.throwing("ModLoader", "RegisterBlock", e);
+			ThrowException(e);
+		}
+	}
+
+	public static void RegisterEntityID(Class<? extends Entity> entityClass, String entityName, int id)
+	{
+		try
+		{
+			method_RegisterEntityID.invoke(null, new Object[] { entityClass, entityName, Integer.valueOf(id) });
+		} catch (IllegalArgumentException e) {
+			logger.throwing("ModLoader", "RegisterEntityID", e);
+			ThrowException(e);
+		} catch (IllegalAccessException e) {
+			logger.throwing("ModLoader", "RegisterEntityID", e);
+			ThrowException(e);
+		} catch (InvocationTargetException e) {
+			logger.throwing("ModLoader", "RegisterEntityID", e);
+			ThrowException(e);
+		}
+	}
+
+	public static void RegisterKey(BaseMod mod, KeyBinding keyHandler, boolean allowRepeat)
+	{
+		Map<KeyBinding, boolean[]> keyMap = keyList.get(mod);
+		if (keyMap == null)
+			keyMap = new HashMap<KeyBinding, boolean[]>();
+			keyMap.put(keyHandler, new boolean[] { allowRepeat });
+			keyList.put(mod, keyMap);
+	}
+
+	public static void RegisterTileEntity(Class<? extends TileEntity> tileEntityClass, String id)
+	{
+		RegisterTileEntity(tileEntityClass, id, null);
+	}
+
+	public static void RegisterTileEntity(Class<? extends TileEntity> tileEntityClass, String id, TileEntitySpecialRenderer renderer)
+	{
+		try
+		{
+			method_RegisterTileEntity.invoke(null, new Object[] { tileEntityClass, id });
+			if (renderer != null) {
+				TileEntityRenderer ref = TileEntityRenderer.instance;
+
+				Map<Class<? extends TileEntity>, TileEntitySpecialRenderer> renderers = (Map<Class<? extends TileEntity>, TileEntitySpecialRenderer>)field_TileEntityRenderers.get(ref);
+				renderers.put(tileEntityClass, renderer);
+				renderer.setTileEntityRenderer(ref);
+			}
+		} catch (IllegalArgumentException e) {
+			logger.throwing("ModLoader", "RegisterTileEntity", e);
+			ThrowException(e);
+		} catch (IllegalAccessException e) {
+			logger.throwing("ModLoader", "RegisterTileEntity", e);
+			ThrowException(e);
+		} catch (InvocationTargetException e) {
+			logger.throwing("ModLoader", "RegisterTileEntity", e);
+			ThrowException(e);
+		}
+	}
+
+	public static void RemoveSpawn(Class<? extends EntityLiving> entityClass, EnumCreatureType spawnList)
+	{
+		RemoveSpawn(entityClass, spawnList, null);
+	}
+
+	public static void RemoveSpawn(Class<? extends EntityLiving> entityClass, EnumCreatureType spawnList, BiomeGenBase[] biomes)
+	{
+		if (entityClass == null) {
+			throw new IllegalArgumentException("entityClass cannot be null");
+		}
+		if (spawnList == null) {
+			throw new IllegalArgumentException("spawnList cannot be null");
+		}
+		if (biomes == null) {
+			biomes = standardBiomes;
+		}
+		for (int i = 0; i < biomes.length; i++) {
+			List<SpawnListEntry> list = biomes[i].getSpawnableList(spawnList);
+
+			if (list != null)
+				for (SpawnListEntry entry : list)
+					if (entry.entityClass == entityClass) {
+						list.remove(entry);
+						break;
+					}
+		}
+	}
+
+	public static void RemoveSpawn(String entityName, EnumCreatureType spawnList)
+	{
+		RemoveSpawn(entityName, spawnList, null);
+	}
+
+	public static void RemoveSpawn(String entityName, EnumCreatureType spawnList, BiomeGenBase[] biomes)
+	{
+		Class entityClass = classMap.get(entityName);
+		if ((entityClass != null) && (EntityLiving.class.isAssignableFrom(entityClass)))
+			RemoveSpawn(entityClass, spawnList, biomes);
+	}
+
+	public static boolean RenderBlockIsItemFull3D(int modelID)
+	{
+		if(!blockSpecialInv.containsKey(Integer.valueOf(modelID)))
+			return modelID == 11;
+		return blockSpecialInv.get(Integer.valueOf(modelID)).booleanValue();
+	}
+
+	public static void RenderInvBlock(RenderBlocks renderer, Block block, int metadata, int modelID)
+	{
+		BaseMod mod = blockModels.get(Integer.valueOf(modelID));
+		if (mod == null)
+			return;
+		mod.RenderInvBlock(renderer, block, metadata, modelID);
+	}
+
+	public static boolean RenderWorldBlock(RenderBlocks renderer, IBlockAccess world, int x, int y, int z, Block block, int modelID)
+	{
+		BaseMod mod = blockModels.get(Integer.valueOf(modelID));
+		if (mod == null)
+			return false;
+		return mod.RenderWorldBlock(renderer, world, x, y, z, block, modelID);
+	}
+
+	public static void saveConfig()
+	throws IOException
+	{
+		cfgdir.mkdir();
+		if(!cfgfile.exists() && !cfgfile.createNewFile())
+		{
+			return;
+		}
+		if(cfgfile.canWrite())
+		{
+			FileOutputStream fileoutputstream = new FileOutputStream(cfgfile);
+			props.store(fileoutputstream, "ModLoader Config");
+			fileoutputstream.close();
+		}
+	}
+
+	public static void SetInGameHook(BaseMod mod, boolean enable, boolean useClock)
+	{
+		if (enable) inGameHooks.put(mod, Boolean.valueOf(useClock)); else
+			inGameHooks.remove(mod);
+	}
+
+	public static void SetInGUIHook(BaseMod mod, boolean enable, boolean useClock)
+	{
+		if (enable) inGUIHooks.put(mod, Boolean.valueOf(useClock)); else
+			inGUIHooks.remove(mod);
+	}
+
+	public static <T, E> void setPrivateValue(Class<? super T> instanceclass, T instance, int fieldindex, E value)
+	throws IllegalArgumentException, SecurityException, NoSuchFieldException
+	{
+		try
+		{
+			Field f = instanceclass.getDeclaredFields()[fieldindex];
+			f.setAccessible(true);
+			int modifiers = field_modifiers.getInt(f);
+			if ((modifiers & 0x10) != 0)
+				field_modifiers.setInt(f, modifiers & 0xFFFFFFEF);
+			f.set(instance, value);
+		} catch (IllegalAccessException e) {
+			logger.throwing("ModLoader", "setPrivateValue", e);
+			ThrowException("An impossible error has occured!", e);
+		}
+	}
+
+	public static <T, E> void setPrivateValue(Class<? super T> instanceclass, T instance, String field, E value)
+	throws IllegalArgumentException, SecurityException, NoSuchFieldException
+	{
+		try
+		{
+			Field f = instanceclass.getDeclaredField(field);
+			int modifiers = field_modifiers.getInt(f);
+			if ((modifiers & 0x10) != 0)
+				field_modifiers.setInt(f, modifiers & 0xFFFFFFEF);
+			f.setAccessible(true);
+			f.set(instance, value);
+		} catch (IllegalAccessException e) {
+			logger.throwing("ModLoader", "setPrivateValue", e);
+			ThrowException("An impossible error has occured!", e);
+		}
+	}
+
+	public static void TakenFromCrafting(EntityPlayer player, ItemStack item)
+	{
+		for (BaseMod mod : modList.values())
+			mod.TakenFromCrafting(player, item);
+	}
+
+	public static void TakenFromFurnace(EntityPlayer player, ItemStack item)
+	{
+		for (BaseMod mod : modList.values())
+			mod.TakenFromFurnace(player, item);
+	}
+
+	public static void OnItemPickup(EntityPlayer player, ItemStack item)
+	{
+		for (BaseMod mod : modList.values())
+			mod.OnItemPickup(player, item);
+	}
+
+	public static void ThrowException(String message, Throwable e)
+	{
+		Minecraft minecraft = getMinecraftInstance();
+		if(minecraft != null)
+		{
+			minecraft.displayUnexpectedThrowable(new UnexpectedThrowable(message, e));
+		} else
+		{
+			throw new RuntimeException(e);
+		}
+	}
+
+	private static void ThrowException(Throwable e)
+	{
+		ThrowException("Exception occured in ModLoader", e);
+	}
 }
diff -r -U 3 minecraft\net\minecraft\GameUpdater.java minecraft_patched\net\minecraft\GameUpdater.java
--- minecraft\net\minecraft\GameUpdater.java	Fri Jun 03 13:31:11 2011
+++ minecraft_patched\net\minecraft\GameUpdater.java	Wed May 18 23:32:51 2011
@@ -367,186 +367,151 @@
         return (Applet)class1.newInstance();
     }
 
-    protected void downloadJars(String s)
-        throws Exception
+    protected void downloadJars(String path)
+    throws Exception
     {
-        File file;
-        Properties properties;
-        int ai[];
-        boolean aflag[];
-        int j;
-        byte abyte0[];
-        int l;
-        file = new File(s, "md5s");
-        properties = new Properties();
-        if(file.exists())
-        {
-            try
-            {
-                FileInputStream fileinputstream = new FileInputStream(file);
-                properties.load(fileinputstream);
-                fileinputstream.close();
-            }
-            catch(Exception exception)
-            {
-                exception.printStackTrace();
-            }
-        }
-        state = 4;
-        ai = new int[urlList.length];
-        aflag = new boolean[urlList.length];
-        for(int i = 0; i < urlList.length; i++)
-        {
-            URLConnection urlconnection = urlList[i].openConnection();
-            urlconnection.setDefaultUseCaches(false);
-            aflag[i] = false;
-            if(urlconnection instanceof HttpURLConnection)
-            {
-                ((HttpURLConnection)urlconnection).setRequestMethod("HEAD");
-                String s1 = (new StringBuilder("\"")).append(properties.getProperty(getFileName(urlList[i]))).append("\"").toString();
-                if(!forceUpdate && s1 != null)
-                {
-                    urlconnection.setRequestProperty("If-None-Match", s1);
-                }
-                int k = ((HttpURLConnection)urlconnection).getResponseCode();
-                if(k / 100 == 3)
-                {
-                    aflag[i] = true;
-                }
-            }
-            ai[i] = urlconnection.getContentLength();
-            totalSizeDownload += ai[i];
-        }
+    	File versionFile = new File(path, "md5s");
+    	Properties md5s = new Properties();
+    	if (versionFile.exists()) {
+    		try {
+    			FileInputStream fis = new FileInputStream(versionFile);
+    			md5s.load(fis);
+    			fis.close();
+    		} catch (Exception e) {
+    			e.printStackTrace();
+    		}
+    	}
+    	state = 4;
+
+    	int[] fileSizes = new int[urlList.length];
+    	boolean[] skip = new boolean[urlList.length];
+
+    	for (int i = 0; i < urlList.length; i++) {
+    		URLConnection urlconnection = urlList[i].openConnection();
+    		urlconnection.setDefaultUseCaches(false);
+    		skip[i] = false;
+    		if ((urlconnection instanceof HttpURLConnection)) {
+    			((HttpURLConnection)urlconnection).setRequestMethod("HEAD");
+
+    			String etagOnDisk = "\"" + md5s.getProperty(getFileName(urlList[i])) + "\"";
+
+    			if ((!forceUpdate) && (etagOnDisk != null)) urlconnection.setRequestProperty("If-None-Match", etagOnDisk);
+
+    			int code = ((HttpURLConnection)urlconnection).getResponseCode();
+    			if (code / 100 == 3) {
+    				skip[i] = true;
+    			}
+    		}
+    		fileSizes[i] = urlconnection.getContentLength();
+    		totalSizeDownload += fileSizes[i];
+    	}
+
+    	int initialPercentage = this.percentage = 10;
+
+    	byte[] buffer = new byte[65536];
+    	for (int i = 0; i < urlList.length; i++) {
+    		if (skip[i]) {
+    			percentage = (initialPercentage + fileSizes[i] * 45 / totalSizeDownload);
+    		}
+    		else
+    		{
+    			try
+    			{
+    				md5s.remove(getFileName(urlList[i]));
+    				md5s.store(new FileOutputStream(versionFile), "md5 hashes for downloaded files");
+    			} catch (Exception e) {
+    				e.printStackTrace();
+    			}
+
+    			int unsuccessfulAttempts = 0;
+    			int maxUnsuccessfulAttempts = 3;
+    			boolean downloadFile = true;
+
+    			while (downloadFile) {
+    				downloadFile = false;
+
+    				URLConnection urlconnection = urlList[i].openConnection();
+
+    				String etag = "";
+
+    				if ((urlconnection instanceof HttpURLConnection)) {
+    					urlconnection.setRequestProperty("Cache-Control", "no-cache");
+
+    					urlconnection.connect();
+
+    					etag = urlconnection.getHeaderField("ETag");
+    					etag = etag.substring(1, etag.length() - 1);
+    				}
+
+    				String currentFile = getFileName(urlList[i]);
+    				InputStream inputstream = getJarInputStream(currentFile, urlconnection);
+    				FileOutputStream fos = new FileOutputStream(path + currentFile);
+
+    				long downloadStartTime = System.currentTimeMillis();
+    				int downloadedAmount = 0;
+    				int fileSize = 0;
+    				String downloadSpeedMessage = "";
+
+    				MessageDigest m = MessageDigest.getInstance("MD5");
+    				int bufferSize;
+    				while ((bufferSize = inputstream.read(buffer, 0, buffer.length)) != -1)
+    				{
+    					fos.write(buffer, 0, bufferSize);
+    					m.update(buffer, 0, bufferSize);
+    					currentSizeDownload += bufferSize;
+    					fileSize += bufferSize;
+    					percentage = (initialPercentage + currentSizeDownload * 45 / totalSizeDownload);
+    					subtaskMessage = ("Retrieving: " + currentFile + " " + currentSizeDownload * 100 / totalSizeDownload + "%");
+
+    					downloadedAmount += bufferSize;
+    					long timeLapse = System.currentTimeMillis() - downloadStartTime;
+
+    					if (timeLapse >= 1000L) {
+    						float downloadSpeed = downloadedAmount / (float)timeLapse;
+    						downloadSpeed = (int)(downloadSpeed * 100.0F) / 100.0F;
+    						downloadSpeedMessage = " @ " + downloadSpeed + " KB/sec";
+    						downloadedAmount = 0;
+    						downloadStartTime += 1000L;
+    					}
+
+    					subtaskMessage += downloadSpeedMessage;
+    				}
+
+    				inputstream.close();
+    				fos.close();
+    				String md5 = new BigInteger(1, m.digest()).toString(16);
+    				while (md5.length() < 32) {
+    					md5 = "0" + md5;
+    				}
+    				boolean md5Matches = true;
+    				if (etag != null) {
+    					md5Matches = md5.equals(etag);
+    				}
+
+    				if ((urlconnection instanceof HttpURLConnection)) {
+    					if ((md5Matches) && ((fileSize == fileSizes[i]) || (fileSizes[i] <= 0)))
+    					{
+    						try {
+    							md5s.setProperty(getFileName(urlList[i]), etag);
+    							md5s.store(new FileOutputStream(versionFile), "md5 hashes for downloaded files");
+    						} catch (Exception e) {
+    							e.printStackTrace();
+    						}
+    					} else {
+    						unsuccessfulAttempts++;
+    						if (unsuccessfulAttempts < maxUnsuccessfulAttempts) {
+    							downloadFile = true;
+    							currentSizeDownload -= fileSize;
+    						} else {
+    							throw new Exception("failed to download " + currentFile);
+    						}
+    					}
+    				}
+    			}
+    		}
+    	}
 
-        j = percentage = 10;
-        abyte0 = new byte[0x10000];
-        l = 0;
-          goto _L1
-_L9:
-        int i1;
-        byte byte0;
-        boolean flag;
-        if(aflag[l])
-        {
-            percentage = j + (ai[l] * 45) / totalSizeDownload;
-            continue; /* Loop/switch isn't completed */
-        }
-        try
-        {
-            properties.remove(getFileName(urlList[l]));
-            properties.store(new FileOutputStream(file), "md5 hashes for downloaded files");
-        }
-        catch(Exception exception1)
-        {
-            exception1.printStackTrace();
-        }
-        i1 = 0;
-        byte0 = 3;
-        flag = true;
-          goto _L2
-_L7:
-        URLConnection urlconnection1;
-        String s2;
-        String s3;
-        InputStream inputstream;
-        FileOutputStream fileoutputstream;
-        long l1;
-        int k1;
-        int i2;
-        String s4;
-        MessageDigest messagedigest;
-        flag = false;
-        urlconnection1 = urlList[l].openConnection();
-        s2 = "";
-        if(urlconnection1 instanceof HttpURLConnection)
-        {
-            urlconnection1.setRequestProperty("Cache-Control", "no-cache");
-            urlconnection1.connect();
-            s2 = urlconnection1.getHeaderField("ETag");
-            s2 = s2.substring(1, s2.length() - 1);
-        }
-        s3 = getFileName(urlList[l]);
-        inputstream = getJarInputStream(s3, urlconnection1);
-        fileoutputstream = new FileOutputStream((new StringBuilder(String.valueOf(s))).append(s3).toString());
-        l1 = System.currentTimeMillis();
-        k1 = 0;
-        i2 = 0;
-        s4 = "";
-        messagedigest = MessageDigest.getInstance("MD5");
-          goto _L3
-_L5:
-        int j1;
-        fileoutputstream.write(abyte0, 0, j1);
-        messagedigest.update(abyte0, 0, j1);
-        currentSizeDownload += j1;
-        i2 += j1;
-        percentage = j + (currentSizeDownload * 45) / totalSizeDownload;
-        subtaskMessage = (new StringBuilder("Retrieving: ")).append(s3).append(" ").append((currentSizeDownload * 100) / totalSizeDownload).append("%").toString();
-        k1 += j1;
-        long l2 = System.currentTimeMillis() - l1;
-        if(l2 >= 1000L)
-        {
-            float f = (float)k1 / (float)l2;
-            f = (float)(int)(f * 100F) / 100F;
-            s4 = (new StringBuilder(" @ ")).append(f).append(" KB/sec").toString();
-            k1 = 0;
-            l1 += 1000L;
-        }
-        this;
-        subtaskMessage;
-        JVM INSTR new #182 <Class StringBuilder>;
-        JVM INSTR dup_x1 ;
-        JVM INSTR swap ;
-        String.valueOf();
-        StringBuilder();
-        s4;
-        append();
-        toString();
-        subtaskMessage;
-_L3:
-        if((j1 = inputstream.read(abyte0, 0, abyte0.length)) != -1) goto _L5; else goto _L4
-_L4:
-        inputstream.close();
-        fileoutputstream.close();
-        String s5;
-        for(s5 = (new BigInteger(1, messagedigest.digest())).toString(16); s5.length() < 32; s5 = (new StringBuilder("0")).append(s5).toString()) { }
-        boolean flag1 = true;
-        if(s2 != null)
-        {
-            flag1 = s5.equals(s2);
-        }
-        if(urlconnection1 instanceof HttpURLConnection)
-        {
-            if(flag1 && (i2 == ai[l] || ai[l] <= 0))
-            {
-                try
-                {
-                    properties.setProperty(getFileName(urlList[l]), s2);
-                    properties.store(new FileOutputStream(file), "md5 hashes for downloaded files");
-                }
-                catch(Exception exception2)
-                {
-                    exception2.printStackTrace();
-                }
-            } else
-            if(++i1 < byte0)
-            {
-                flag = true;
-                currentSizeDownload -= i2;
-            } else
-            {
-                throw new Exception((new StringBuilder("failed to download ")).append(s3).toString());
-            }
-        }
-_L2:
-        if(flag) goto _L7; else goto _L6
-_L6:
-        l++;
-_L1:
-        if(l < urlList.length) goto _L9; else goto _L8
-_L8:
-        subtaskMessage = "";
-        return;
+    	subtaskMessage = "";
     }
 
     protected InputStream getJarInputStream(String s, final URLConnection urlconnection)
@@ -824,43 +789,30 @@
 
     public boolean canPlayOffline()
     {
-        File file;
-        String s = (String)AccessController.doPrivileged(new PrivilegedExceptionAction() {
-
-            public Object run()
-                throws Exception
-            {
-                return (new StringBuilder()).append(Util.getWorkingDirectory()).append(File.separator).append("bin").append(File.separator).toString();
-            }
-
-        }
-);
-        file = new File(s);
-        if(!file.exists())
-        {
-            return false;
-        }
-        file = new File(file, "version");
-        if(!file.exists())
-        {
-            return false;
-        }
-        String s1;
-        if(!file.exists())
-        {
-            break MISSING_BLOCK_LABEL_87;
-        }
-        s1 = readVersionFile(file);
-        if(s1 != null && s1.length() > 0)
-        {
-            return true;
-        }
-        break MISSING_BLOCK_LABEL_87;
-        Exception exception;
-        exception;
-        exception.printStackTrace();
-        return false;
-        return false;
+    	try
+    	{
+    		String path = (String)AccessController.doPrivileged(new PrivilegedExceptionAction() {
+    			public Object run() throws Exception {
+    				return Util.getWorkingDirectory() + File.separator + "bin" + File.separator;
+    			}
+    		});
+    		File dir = new File(path);
+    		if (!dir.exists()) return false;
+
+    		dir = new File(dir, "version");
+    		if (!dir.exists()) return false;
+
+    		if (dir.exists()) {
+    			String version = readVersionFile(dir);
+    			if ((version != null) && (version.length() > 0))
+    				return true;
+    		}
+    	}
+    	catch (Exception e) {
+    		e.printStackTrace();
+    		return false;
+    	}
+    	return false;
     }
 
     public static final int STATE_INIT = 1;
diff -r -U 3 minecraft\net\minecraft\Util.java minecraft_patched\net\minecraft\Util.java
--- minecraft\net\minecraft\Util.java	Fri Jun 03 13:31:11 2011
+++ minecraft_patched\net\minecraft\Util.java	Wed May 18 23:32:51 2011
@@ -14,51 +14,9 @@
 
 public class Util
 {
-    private static final class OS extends Enum
-    {
-
-        public static OS[] values()
-        {
-            OS aos[];
-            int i;
-            OS aos1[];
-            System.arraycopy(aos = ENUM$VALUES, 0, aos1 = new OS[i = aos.length], 0, i);
-            return aos1;
-        }
-
-        public static OS valueOf(String s)
-        {
-            return (OS)Enum.valueOf(net.minecraft.Util$OS.class, s);
-        }
-
-        public static final OS linux;
-        public static final OS solaris;
-        public static final OS windows;
-        public static final OS macos;
-        public static final OS unknown;
-        private static final OS ENUM$VALUES[];
-
-        static 
-        {
-            linux = new OS("linux", 0);
-            solaris = new OS("solaris", 1);
-            windows = new OS("windows", 2);
-            macos = new OS("macos", 3);
-            unknown = new OS("unknown", 4);
-            ENUM$VALUES = (new OS[] {
-                linux, solaris, windows, macos, unknown
-            });
-        }
-
-        private OS(String s, int i)
-        {
-            super(s, i);
-        }
-    }
-
-
-    public Util()
+    private static enum OS
     {
+        linux, solaris, windows, macos, unknown;
     }
 
     public static File getWorkingDirectory()
@@ -74,7 +32,7 @@
     {
         String s1 = System.getProperty("user.home", ".");
         File file;
-        switch($SWITCH_TABLE$net$minecraft$Util$OS()[getPlatform().ordinal()])
+        switch(getPlatform().ordinal())
         {
         case 1: // '\001'
         case 2: // '\002'
@@ -228,44 +186,5 @@
         }
     }
 
-    static int[] $SWITCH_TABLE$net$minecraft$Util$OS()
-    {
-        $SWITCH_TABLE$net$minecraft$Util$OS;
-        if($SWITCH_TABLE$net$minecraft$Util$OS == null) goto _L2; else goto _L1
-_L1:
-        return;
-_L2:
-        JVM INSTR pop ;
-        int ai[] = new int[OS.values().length];
-        try
-        {
-            ai[OS.linux.ordinal()] = 1;
-        }
-        catch(NoSuchFieldError _ex) { }
-        try
-        {
-            ai[OS.macos.ordinal()] = 4;
-        }
-        catch(NoSuchFieldError _ex) { }
-        try
-        {
-            ai[OS.solaris.ordinal()] = 2;
-        }
-        catch(NoSuchFieldError _ex) { }
-        try
-        {
-            ai[OS.unknown.ordinal()] = 5;
-        }
-        catch(NoSuchFieldError _ex) { }
-        try
-        {
-            ai[OS.windows.ordinal()] = 3;
-        }
-        catch(NoSuchFieldError _ex) { }
-        return $SWITCH_TABLE$net$minecraft$Util$OS = ai;
-    }
-
     private static File workDir = null;
-    private static int $SWITCH_TABLE$net$minecraft$Util$OS[]; /* synthetic field */
-
 }